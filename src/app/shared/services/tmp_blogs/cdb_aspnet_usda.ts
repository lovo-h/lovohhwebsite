import { hyphenFn } from './common';
import { Blog } from '../../class';


export const cdb_aspnet_usda_p1 = new Blog(
  'Recreating the USDA National Nutrient Database Using MSSQL on Docker - Part 1',
  hyphenFn('Recreating the USDA National Nutrient Database Using MSSQL on Docker Part 1'),
  'Hector Lovo',
  'https://lovohh.com',
  'assets/imgs/blog/aspnet_usda/aspnet_usda.png',
  'Backend',
  '04/22/2018',
  'The Docker image in this tutorial uses data provided by the USDA\'s Agricultural Research Service (USDA ARS). According to the USDA ARS, this data is one of the major sources of food composition data in the United States and provides the foundation for most food composition databases in the public and private sectors.',
  '<p><strong>Note to the reader</strong>: because the topic in this blog is discussed a bit in-depth, it has become too long to post in a single blog-post. So, it will be delivered in a multi-part series, composed of three separate blog-posts.</p><p>In case you would like to navigate around the posts, here they are:</p><ul><li><strong>Part One</strong>: <a href="blog/recreating-the-usda-national-nutrient-database-using-mssql-on-docker-part-1">Foundation and Getting Started</a></li><li><strong>Part Two</strong>: <a href="blog/recreating-the-usda-national-nutrient-database-using-mssql-on-docker-part-2">App Configuration</a></li><li><strong>Part Three</strong>: <a href="blog/recreating-the-usda-national-nutrient-database-using-mssql-on-docker-part-3">Parsing Data and Conclusion</a></li></ul><h2>Introduction</h2><p>I recently found myself in need of nutrition-related data for an app I was in the process of designing. I was able to find an application programming interface (API) online, provided by the <em>United States Department of Agriculture</em> (USDA) but I wanted the data to be stored locally; mostly because I wanted the app to be independent from a third-party. Thankfully, I discovered that the USDA also provides the same API&rsquo;s nutrition-data in other formats that can be more easily parsed and stored into one&rsquo;s own database. That is the topic this blog will cover, the step-by-step process for parsing and storing this data into a <em>Docker image</em>.</p><p>More specifically, this <em>Docker image</em> uses data provided by the <em>USDA\'s Agricultural Research Service</em> (USDA ARS). According to the USDA ARS, this data is one of the major sources of food composition data in the <em>United States</em> and provides the foundation for most food composition databases in the public and private sectors (USDA ARS, 2018). They indicate that this data contains information on 7,793 food items and up to 150 food components.</p><p>It should be made clear that, although, this blog will discuss the creation of a <em>Docker image</em> housing this data, the USDA also provides an API, as mentioned earlier, that can be used as an alternative to this <em>Docker image</em>. To learn more about the NDB API, <a href="https://ndb.nal.usda.gov/ndb/doc/apilist/API-FOOD-REPORTV2.md">check out their documentation here</a>.</p><p>When would you want to use the API versus the <em>Docker image</em>?</p><p>To determine whether to use this <em>Docker image</em> as opposed to the USDA&rsquo;s provided API, one should first determine what better fits their app&rsquo;s needs. Here are a few deciding factors, in no particular order:</p><ul><li>Control of the data in the database versus up-to-date data<ul><li>If using the API, the data will, in theory, always be up-to-date</li><li>If using the <em>Docker image</em>, one will need to update the image when the USDA ARS&rsquo;s releases updates</li></ul></li><li>Third-party dependency versus independent apps<ul><li>If using the API, one&rsquo;s app will require an Internet connection to access the data</li><li>If using the <em>Docker image</em>, one&rsquo;s app will be independent of the API&rsquo;s up-time and can function with or without an Internet connection</li></ul></li><li>Computing resources versus outsourced resources<ul><li>If using the <em>Docker image</em>, one will require to use more computing resources to host the database themselves</li></ul></li></ul><p>Although it should go without saying, these are just a few factors that should be considered for deciding which approach better fits one\'s app\'s needs.</p><p>If you are wondering how others are using this nutrition data, according to the USDA ARS, this data is used:</p><ul><li>To develop nutrient values for the <em>Food and Nutrient Database for Dietary Studies</em> (FNDDS).<ul><li>The FNDDS is used for assessment of nutrient intakes in the <em>What We Eat in America</em> component of the <em>National Health and Nutrition Examination Survey</em> used for national nutrition monitoring</li></ul></li><li>In developing the <em>Dietary Guidelines for Americans and Dietary Reference Intakes</em> for a wide variety of nutrients</li><li>In creating meal plans in schools and day-care centers</li><li>In product development, and labeling by manufacturers</li><li>By researchers in academia and government, dietitians advising their clients, and consumers interested in the nutrient content of their food</li></ul><p>Hopefully, this is sufficiently convincing evidence that this data has been deemed reliable by accredited institutions.</p><p>Finally, note that, although, this <em>Docker image</em> could have been released without the need for this blog-post, it was mostly written to reassure the user that the data has been indeed processed correctly into the database and therefore it is a reliable image. This blog-post will demonstrate this by taking the reader through a step-by-step process of the creation of this <em>Docker image</em>.</p><h2>Foundation</h2><p>The USDA ARS provides access to two formats for which a user can download the nutrition-data. One format is the <em>Microsoft Access Database</em> format and the other is the ASCII text file format. This blog will be using the ASCII files which can be <a href="https://www.ars.usda.gov/ARSUserFiles/80400525/Data/SR-Legacy/SR-Leg_ASC.zip">downloaded in a ZIP format from the USDA\'s website, here</a>.</p><p>Once the ZIP file has been downloaded,  let\'s extract its content and verify that there are twelve ASCII text-files (data) and one PDF file (documentation).</p><p>These are the files that should exist in your extracted directory:</p><pre class="bt-fmt-txt"><code>1. DATA_SRC.txt            8. LANGUAL.txt</code><br /><code>2. DATSRCLN.txt            9. NUT_DATA.txt</code><br /><code>3. DERIV_CD.txt           10. NUTR_DEF.txt</code><br /><code>4. FD_GROUP.txt           11. SRC_CD.txt</code><br /><code>5. FOOD_DES.txt           12. WEIGHT.txt</code><br /><code>6. FOOTNOTE.txt           13. SR-Legacy_Doc.pdf</code><br /><code>7. LANGDESC.txt</code></pre><p>Next, let\'s talk about the design that we will use to create the database. By planning the design early on, we can save ourselves some hassle later on.</p><p>First, let&rsquo;s layout some of the groundwork: using the documentation file <code class="bt-file">SR-Legacy_Doc.pdf</code> (USDA ARS&rsquo; Documentation and User Guide) as reference, let&rsquo;s create the relationships between the tables in the database.</p><p><strong>Figure 1</strong>, below, borrowed from the USDA ARS&rsquo; documentation, describes how tables can be related to each other.</p><p class="bt-img"><img src="assets/imgs/blog/cdb_aspnet_usda/fig1_relations.png"></p><p>More specifically, <strong>Figure 1</strong> describes the twelve table&rsquo;s names, primary keys (the underlined items), and how the tables can relate to each other (the arrows). Although, <strong>Figure 1</strong> relays a good bit of information, we will require more detail to be able to create the database to its entirety.</p><p>We can also find <strong>Table 1</strong>, below, in the documentation file <code class="bt-file">SR-Legacy_Doc.pdf</code>:</p><p class="bt-img"><img src="assets/imgs/blog/cdb_aspnet_usda/tbl1_content.png"></p><pre class="bt-fmt-txt"><code>     </code></pre><p>Using <strong>Table 1</strong> and the pages it references, we can construct the following schema (<strong>Figure 2</strong>):</p><pre class="bt-fmt-txt"><code>     </code></pre><p class="bt-img"><img src="assets/imgs/blog/icdicdb/usdafood_schema.png"></p><p><strong>Figure 2</strong> relays more information. More specifically, it shows:</p><ul><li>The tables&rsquo; names</li><li>The primary keys for each table</li><li>All of the fields of each table<ul><li>The field&rsquo;s name, type, and length</li></ul></li><li>More detailed description of how tables relate to each other<ul><li>Primary keys: fields with key-icons on them</li><li>Foreign keys: fields with arrows pointing out to a primary key in another table</li></ul></li></ul><p>For more clarity, let&rsquo;s make the type-of-relationships between these tables, abundantly clear:</p><pre class="bt-fmt-txt"><code><strong>ONE</strong>  FOOD_DES to <strong>MANY</strong> NUT_DATA</code><br /><code><strong>ONE</strong>  FOOD_DES to <strong>MANY</strong> WEIGHT</code><br /><code><strong>ONE</strong>  FOOD_DES to <strong>MANY</strong> FOOTNOTE</code><br /><code><strong>ONE</strong>  FD_GROUP to <strong>MANY</strong> FOOD_DES</code><br /><code><strong>MANY</strong> FOOD_DES to <strong>MANY</strong> LANGDESC (intermediary: LANGUAL)</code><br /><code><strong>ONE</strong>  SRC_CD   to <strong>MANY</strong> NUT_DATA</code><br /><code><strong>ONE</strong>  DERIV_CD to <strong>MANY</strong> NUT_DATA</code><br /><code><strong>ONE</strong>  NUTR_DEF to <strong>MANY</strong> NUT_DATA</code><br /><code><strong>MANY</strong> NUT_DATA to <strong>MANY</strong> DATA_SRC (intermediary: DATASRCLN)</code></pre><p>We now have all the relevant database-design information to be able to create it in the code. Throughout this blog, the list of table-relationship types, <strong>Figure 2</strong>, <strong>Table 1</strong> and the pages that it references to, will be used as the main guiding data.</p><p>Let&rsquo;s get started!</p><h2>Getting Started</h2><p>It should be noted that the following tools need to already be installed on your computer before we begin.</p><p><span class="bt-underline">Prerequisites</span></p><ul><li><a href="https://docs.docker.com/install/">Docker</a></li><li><a href="https://docs.docker.com/compose/install/">Docker Compose</a></li><li><a href="https://www.microsoft.com/net/learn/get-started/macos">Dotnet</a></li></ul><p><strong>Note</strong>: If you would like to follow along with the code, <a href="https://github.com/lovo-h/ASPNet_USDAFoodDB">the Github repository <strong>ASPNet_USDAFoodDB</strong> can be found here</a>.</p><h3>Step 0. Get Setup</h3><p>We will start by setting up the work-environment:</p><ol><li>Create a new directory and name it <code class="bt-dir">USDAFoodDB</code>: root directory</li><li>Navigate into the newly created directory, <code class="bt-dir">USDAFoodDB</code></li><li>In the <code class="bt-dir">USDAFoodDB</code> directory:<ol><li>Create the following file:<ol><li><code class="bt-file">docker-compose.yml</code>:  file to configure the <em>MSSQL Docker image</em></li></ol></li><li>Create the following directories:<ol><li><code class="bt-dir">Context</code>: directory that will host files used to create a session with the database</li><li><code class="bt-dir">Models</code>: directory that will host the database entities as a class/object</li><li><code class="bt-dir">Src</code>: directory that will host the data (text-files) retrieved from the USDA website</li><li><code class="bt-dir">Tools</code>: directory that will host classes/objects used throughout the app</li></ol></li></ol></li></ol><p>At this point, we are ready to copy the directory (<code class="bt-dir">SR-Leg_ASC</code>) containing the twelve text-files that were retrieved from the USDA website into the <code class="bt-dir">Src</code> directory. Notice that <a href="https://github.com/lovo-h/ASPNet_USDAFoodDB/tree/master/Src">the <em>Github</em> repository for this blog</a> contains these files but in a ZIP format.</p><h3>Step 1. Initialize the App</h3><p>Let&rsquo;s start by initializing a console-app using the <code>dotnet</code> tool. First, open-up a new terminal (<code>t1</code>) window, navigate to the root directory <code class="bt-dir">USDAFoodDB</code> in the terminal <code>t1</code>, and run the following command:</p><pre class="bt-cmd-in"><code>dotnet new console</code></pre><p>The <code>dotnet</code> tool has now generated a console-app for us. If we run this console-app, by running the following command:</p><pre class="bt-cmd-in"><code>dotnet run</code></pre><p>We should see the following output:</p><pre class="bt-cmd-out"><code>Hello World!</code></pre><p>That is all that is needed to create a console-app, using the <code>dotnet</code> tool. This console-app will be used as the managing-agent that retrieves all of the nutrition-data  and stores that data into the <em>MSSQL Docker image</em>. Next, we will initialize the aforementioned <em>Docker image</em>.</p><h3>Step 2. Initialize the Default MSSQL-Server Docker Image</h3><p>To create the <em>USDA Nutrient Database Docker image</em>, first, we will need to establish a base image that will function as the foundation. We will be using <code>microsoft/mssql-server-linux:latest</code> as the base image. <a href="https://hub.docker.com/r/microsoft/mssql-server-linux/">See the Docker-Hub repository for this image by clicking here</a>.</p><p>Make the following changes to the <code class="bt-file">docker-compose.yml</code> file in your favorite text-editor or IDE:</p><pre class="bt-code"><code>version: "3"<br /><br />services:<br />   mssql-usdafooddb:<br />      image: <strong>microsoft/mssql-server-linux:latest</strong><br />      container_name: mssql-usdafooddb<br />      ports:<br />         - 1433:1433<br />      environment:<br />         - ACCEPT_EULA=Y<br />         - SA_PASSWORD=password123!<br />         - COMPOSE_HTTP_TIMEOUT=120</code></pre><p>For more information on the configuration of this <em>Docker image</em>, <a href="https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker?view=sql-server-linux-2017">see the Quickstart: Run the SQL Server 2017 container image with Docker tutorial</a>.</p><p>Now, let&rsquo;s open-up a new terminal (<code>t2</code>) window, navigate to the root directory <code class="bt-dir">USDAFoodDB</code>, and run the following command:</p><pre class="bt-cmd-in"><code>docker-compose up</code></pre><p><strong>Note</strong>: we will be leaving this terminal (<code>t2</code>) window running in the background.</p><p>If this is the first time attempting to use the <code>microsoft/mssql-server-linux:latest</code> image, <em>Docker</em> will have to first download the image from <em>Docker-Hub</em>. Once the image has been downloaded, <em>Docker</em> will boot-up the image.</p><p>At this point, we should have a <em>Microsoft SQL Server</em> running in a <em>Docker</em> container but we still need to add the nutrition-data. We will do that soon but first let&rsquo;s verify whether we are able to connect to the container.</p><h3>Step 3. Connect to the MSSQL-Server Docker Container</h3><p>Before we can connect to the <em>Docker</em> container, we are going to need the <em>Entity Framework Core</em> (EFC) package added to the project. To add this package, run the following command on the first terminal (<code>t1</code>) window:</p><pre class="bt-cmd-in"><code>dotnet add package Microsoft.EntityFrameworkCore</code></pre><p>Ensure that no errors are displayed to determine whether the package was successfully added.</p><p>According to EFC&rsquo;s docs, EFC is a lightweight, extensible, and cross-platform version of the <em>Entity Framework</em> data access technology. It can serve as an object-relational mapper (OR/M) by using .NET objects to communicate with the database. For more <a href="https://docs.microsoft.com/en-us/ef/core/">information on the Entity Framework Core, see the docs</a>.</p><p>Additionally, since we will be using <em>Microsoft SQL Server</em> for this project, we are also going to need to install the <em>SQL Server</em> provider. This can be done by running the following command:</p><pre class="bt-cmd-in"><code>dotnet add package Microsoft.EntityFrameworkCore.SqlServer</code></pre><p>Again, ensure that no errors are displayed during installation to determine whether the package was successfully added. Now that the app has the necessary packages, it is ready to connect to the database.</p><p>To connect to the database, make the following changes, marked in bold, to the <code class="bt-file">./USDAFoodDB/Program.cs</code> file:</p><pre class="bt-code"><code>using System;<br /><strong>using System.Data.SqlClient;</strong><br /><br />namespace USDAFoodDB { <br />   class Program {<br /><strong>#1    private const string ConnString = "Server=localhost,1433;Database=master;" + <br />                                        "User Id=sa;Password=password123!;" +<br />                                        "MultipleActiveResultSets=true";</strong> <br /><br />      static void Main() {<br /><strong>#2       var connection = new SqlConnection(ConnString);<br />                           <br />#3       try { <br />            connection.Open(); <br />            Console.WriteLine("Successfully connected."); <br />            connection.Close(); <br />         } catch (Exception ex) { <br />            Console.WriteLine("Cannot open a connection:" + ex.Message);<br />         }</strong><br />      }<br />   }<br />}</code></pre><p>Here&rsquo;s a quick explanation of what&rsquo;s going on inside this code:</p><ol><li>Define the connection string (<code>ConnString</code>) that will allow the <code>SqlClient</code> to connect with the database.</li><li>Initialize an instance of <code>SqlConnection</code>, using the connection-string.</li><li>Make an attempt to connect to the database, in a <code>try-catch</code> statement,.</li></ol><p>A few things to note about the structure of the connection string <code>ConnString</code>:</p><ul><li>It&rsquo;s a string containing key/value pairs separated by semicolons and it is used by the <code>SqlClient</code>.</li><li>Because, earlier, in the <code class="bt-file">docker-compose.yml</code> file, we mapped port 1433 from the <em>MSSQL Docker image</em> to the host, we can reference the <code>Server</code> key&rsquo;s value to <a href="http://localhost:1433">localhost:1433</a> to access the container; assuming the container is still running in the second terminal (<code>t2</code>) window.</li><li>The <code>Database</code> key currently points to <code>master</code> because that is the default database for the user <code>sa</code>.</li><li>The <code>User Id</code> refers to the system administrator (<code>sa</code>).</li><li>Finally, for the <code>Password</code>, we are reusing the same password we set in the <code class="bt-file">docker-compose.yml</code>. <strong>Note</strong>: these passwords have to match to gain access to the server.</li></ul><p>Now, if we run the console-app once again:</p><pre class="bt-cmd-in"><code>dotnet run</code></pre><p>We should see the following output:</p><pre class="bt-cmd-out"><code>Successfully connected.</code></pre><p>We have successfully connected to the MSSQL server and we are ready to move forward. As mentioned earlier, the <em>Entity Framework Core</em> provides the advantage of being able to use object-relational mapping to interact with the database. So, next, we will be creating the classes that will represent these entities in the database.</p><h3>What\'s Next?</h3><p>This blog continues in <strong>Part 2</strong>: <a href="blog/recreating-the-usda-national-nutrient-database-using-mssql-on-docker-part-2">App Configuration</a>.</p>\n',
  10,
  0
);

export const cdb_aspnet_usda_p2 = new Blog(
  'Recreating the USDA National Nutrient Database Using MSSQL on Docker - Part 2',
  hyphenFn('Recreating the USDA National Nutrient Database Using MSSQL on Docker Part 2'),
  'Hector Lovo',
  'https://lovohh.com',
  'assets/imgs/blog/aspnet_usda/aspnet_usda.png',
  'Backend',
  '04/29/2018',
  'In this blog-post, we begin configuring table-relationships. Since this blogâ€™s database-design requires a slightly more complex relationship-configuration, it resorts to using the Fluent API approach. The Fluent API configuration takes higher precedence over all other configuration approaches.',
  '<p><strong>Note to the reader</strong>: because the topic in this blog is discussed a bit in-depth, it has become too long to post in a single blog-post. So, it will be delivered in a multi-part series, composed of three separate blog-posts.</p><p>In case you would like to navigate around the posts, here they are:</p><ul><li><strong>Part One</strong>: <a href="blog/recreating-the-usda-national-nutrient-database-using-mssql-on-docker-part-1">Foundation and Getting Started</a></li><li><strong>Part Two</strong>: <a href="blog/recreating-the-usda-national-nutrient-database-using-mssql-on-docker-part-2">App Configuration</a></li><li><strong>Part Three</strong>: <a href="blog/recreating-the-usda-national-nutrient-database-using-mssql-on-docker-part-3">Parsing Data and Conclusion</a></li></ul><h2>App Configuration</h2><p>Recall, from <strong>Part One</strong>: <a href="blog/recreating-the-usda-national-nutrient-database-using-mssql-on-docker-part-1">Foundation and Getting Started</a>, that the database has twelve entities so we will need to create twelve classes to represent these entities. Since we require so many, this blog will demonstrate the creation of one of the classes as an example but the remaining can be created by following a similar pattern. The finished product of the other classes can be viewed on <a href="https://github.com/lovo-h/ASPNet_USDAFoodDB/tree/master/Models">the Github repo for this blog</a>.</p><h3>Step 4. Create the Models</h3><p>First, let&rsquo;s create the file that will contain the class for the FOOD_DES entity. So, in the <code class="bt-dir">./USDAFoodDB/Models/</code> directory, add a file named <code class="bt-file">FoodDes.cs</code>.</p><p>Using <strong>Figure 2. Relationships Among Tables</strong> from <strong>Part One</strong>: <a href="blog/recreating-the-usda-national-nutrient-database-using-mssql-on-docker-part-1">Foundation and Getting Started</a> as reference, we know <code class="bt-file">FoodDes.cs</code> will look like the following:</p><pre class="bt-code"><code>namespace USDAFoodDB.Models {<br />   public class FoodDes {<br />      public string NdbNo       { get; set; }<br />      public string FdGrpCd     { get; set; }<br />      public string LongDesc    { get; set; }<br />      public string ShrtDesc    { get; set; }<br />      public string ComName     { get; set; }<br />      public string ManufacName { get; set; }<br />      public string Survey      { get; set; }<br />      public string RefDesc     { get; set; }<br />      public int    Refuse      { get; set; }<br />      public string SciName     { get; set; }<br />      public double NFactor     { get; set; }<br />      public double ProFactor   { get; set; }<br />      public double FatFactor   { get; set; }<br />      public double ChoFactor   { get; set; }<br />   }<br />}</code></pre><p>Proceed to create the remaining eleven classes, making sure to use the documentation to add all the pertinent properties, and making sure to follow the same naming convention, and casing (<a href="http://wiki.c2.com/?PascalCase">Pascal Casing</a>), as in <code class="bt-file">FoodDes.cs</code>.</p><h3>Step 5. Table Relationships &ndash; Definitions</h3><p>Before we define the relationships between entities, first, this blog will define some terminology to make things easier to understand.</p><p>Note, <a href="https://docs.microsoft.com/en-us/ef/core/modeling/relationships">the definitions of these terms are extracted directly from the EFC docs</a> but for convenience are also copied here:</p><ul><li><strong>Dependent entity</strong>: the entity that contains the foreign key property(s). Sometimes referred to as the &lsquo;child&rsquo; of the relationship.</li><li><strong>Principal entity</strong>: the entity that contains the primary/alternate key property(s). Sometimes referred to as the &lsquo;parent&rsquo; of the relationship.</li><li><strong>Foreign key</strong>: the property(s) in the dependent entity that is used to store the values of the principal key property that the entity is related to.</li><li><strong>Principal key</strong>: the property(s) that uniquely identifies the principal entity. This may be the primary key or an alternate key.</li></ul><p>When creating a relationship between two tables, the relationship needs to identify which table is the dependent entity and which one is the principal entity. We can identify which one is which by first identifying the foreign and principal keys and how they relate. By doing this, we should end up with the following relationships:</p><pre class="bt-fmt-txt"><code><strong>ONE</strong>  FOOD_DES (principal) to <strong>MANY</strong> NUT_DATA (dependent)<br /><strong>ONE</strong>  FOOD_DES (principal) to <strong>MANY</strong> WEIGHT   (dependent)<br /><strong>ONE</strong>  FOOD_DES (principal) to <strong>MANY</strong> FOOTNOTE (dependent)<br /><strong>ONE</strong>  FD_GROUP (principal) to <strong>MANY</strong> FOOD_DES (dependent)<br /><strong>MANY</strong> FOOD_DES (principal) to <strong>MANY</strong> LANGDESC (principal) (intermediary: LANGUAL (dependent))<br /><strong>ONE</strong>  SRC_CD   (principal) to <strong>MANY</strong> NUT_DATA (dependent)<br /><strong>ONE</strong>  DERIV_CD (principal) to <strong>MANY</strong> NUT_DATA (dependent)<br /><strong>ONE</strong>  NUTR_DEF (principal) to <strong>MANY</strong> NUT_DATA (dependent)<br /><strong>MANY</strong> NUT_DATA (principal) to <strong>MANY</strong> DATA_SRC (principal) (intermediary: DATSRCLN (dependent))</code></pre><p>How might these relationship dynamics affect our code? For starters, when we are inserting data into the tables, we need to ensure that an instance of the principal entity exists before any instance of the dependent entity can be inserted. Otherwise, we will get a database insertion-error. More on this later.</p><p>Now that we have a better idea of how the entities are related to each other, let&rsquo;s switch gears and begin to build the code that will allow us to connect to the database. We will begin by creating a <code>DbContext</code>.</p><h3>Step 6. Table Relationships - DbContext</h3><p>According to <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.dbcontext?view=efcore-2.1">the Entity Framework Core docs</a>:</p><ul><li><code><strong>DbContext</strong></code>: an instance of this represents a session with the database and can be used to query and save instances of your entities.</li></ul><p>In other words, the <code>DbContext</code> will facilitate the conversion of data between the console-app and the database.</p><p>So, let&rsquo;s create a file named <code class="bt-file">USDAFoodContext.cs</code> in the <code class="bt-dir">./USDAFoodDB/Context/</code> directory. Then, let&rsquo;s make the following changes to the newly created <code class="bt-file">USDAFoodContext.cs</code> file:</p><pre class="bt-code"><code>using Microsoft.EntityFrameworkCore;<br /><br />namespace USDAFoodDB.Context {<br />   public class USDAFoodContext : DbContext {<br />      public DbContextOptions DbContextOptions;<br /><br />      public USDAFoodContext(DbContextOptions options) : base(options) {<br />         DbContextOptions = options;<br />      }<br />   }<br />}</code></pre><p>This block of code defines a class named <code>USDAFoodContext</code> that inherits from <code>DbContext</code>. We have also created a constructor for <code>USDAFoodContext</code> that accepts a parameter of type <code>DbContextOptions</code>. It should be noted that <code>USDAFoodContext</code> requires an instance of <code>DbContextOptions</code> to be able to perform any actual work.</p><p>According to the docs, an instance of <code>DbContextOptions</code> carries configuration information such as:</p><ul><li>The database provider to use</li><li>Any necessary connection string or identifier of the database instance</li><li>Any provider-level optional behavior selectors</li><li>Any general EFC behavior selectors</li></ul><p>We will have a chance to revisit <code>DbContextOptions</code> some more later, when we create an instance to pass into <code>USDAFoodContext</code>.</p><p>At this point, we have a <code>DbContext</code> named <code>USDAFoodContext</code> but it is not yet aware of the entities that need to be associated with the database. To make the <code>DbContext</code> aware of these entities, we will need to specify a <code>DbSet&lt;TEntity&gt;</code> property for each entity. According to the docs, &ldquo;a DbSet represents the collection of all entities in the context, or that can be queried from the database, of a given type.&rdquo; <a href="https://msdn.microsoft.com/en-us/library/gg696460(v=vs.113).aspx">See the docs for more information on the DbSet&lt;TEntity&gt; class</a>.</p><p>Let&rsquo;s add the <code>DbSet&lt;TEntity&gt;</code> property for the <code>FoodDes</code> entity by making the following changes, marked in bold, to the <code class="bt-file">USDAFoodContext.cs</code> file:</p><pre class="bt-code"><code>using Microsoft.EntityFrameworkCore;<br /><strong>using USDAFoodDB.Models;</strong><br /><br />namespace USDAFoodDB.Context {<br />   public class USDAFoodContext : DbContext {<br />      public DbContextOptions DbContextOptions;<br /><strong><br />      public DbSet FoodDeses { get; set; }</strong><br /><br />      public USDAFoodContext(DbContextOptions options) : base(options) {<br />         DbContextOptions = options;<br />      }<br />   }<br />}</code></pre><p>Go ahead and add the remaining eleven entities to the <code>USDAFoodContext</code> in a similar fashion.</p><p>Now that the <code>USDAFoodContext</code> is aware of all of the entities, we can proceed to further shape each entity. There exist three methods for shaping, or configuring, these entities but we will be using the <em>Fluent API</em> method.</p><h3>Step 7. Table Relationships &ndash; Fluent API</h3><p>By default, the <em>Entity Framework</em> uses a set of conventions to build a model based on the shape of the entity class (e.g. <code>FoodDes</code>&rsquo;s properties). But, it also allows for two additional methods for configuration:</p><ol><li>By using the <em>Fluent API</em></li><li>By applying <em>Data Annotations</em> on the classes</li></ol><p>It should be noted that the <em>Fluent API</em> configuration takes higher precedence over the <em>Data Annotations</em> configuration. Also, the <em>Data Annotations</em> configuration takes higher precedence over the default set of conventions configuration. This blog&rsquo;s database-design requires a slightly more complex relationship-configuration so it will resort to using the <em>Fluent API</em> approach.</p><p>To gain access to the <em>Fluent API</em>, we are going to need to update the <code class="bt-file">USDAFoodContext.cs</code> file to override the following class-method, marked in bold (note, some code was omitted for brevity):</p><pre class="bt-code"><code>using Microsoft.EntityFrameworkCore;<br />using USDAFoodDB.Models;<br /><br />namespace USDAFoodDB.Context {<br />   public class USDAFoodContext : DbContext {<br />      &hellip;<br /><strong>      protected override void OnModelCreating(ModelBuilder modelBuilder) {<br />         base.OnModelCreating(modelBuilder);<br />      }</strong><br />   }<br />}</code></pre><p>Next, we will create the individual methods that will configure each entity and they will be called from within <code>OnModelCreating(...)</code>. Again, instead of explaining how to configure each individual entity, this blog will configure one entity (<code>FoodDes</code>) and allow the reader to configure the remaining entities by using <code>FoodDes</code> as an example.</p><p>To be able to configure the entity, <code>FoodDes</code>, we are going to need to refer to the docs: <code class="bt-file">SR-Legacy_Doc.pdf</code> file (<em>USDA ARS&rsquo; Documentation and User Guide</em>). In the docs, on page six, you can find <strong>Table 1</strong> (also included in this blog-series in <strong>Part One</strong>: <a href="blog/recreating-the-usda-national-nutrient-database-using-mssql-on-docker-part-1">Foundation and Getting Started</a>). <strong>Table 1</strong> redirects us to page ten where we can obtain more information on how to configure <code>FoodDes</code>. On page ten, we learn the following about <code>FoodDes</code>:</p><ul><li>NDB_No is the primary/principal key</li><li>NDB_No, FdGrp_Cd, Long_Desc, and Shrt_Desc cannot be empty</li><li>The type and length of each field</li></ul><p>Let&rsquo;s configure the <code>FoodDes</code> entity to reflect this information. To apply these configurations, make the following changes, marked in bold, to the <code class="bt-file">USDAFoodContext.cs</code> file (note, some code was omitted for brevity):</p><pre class="bt-code"><code>using Microsoft.EntityFrameworkCore;<br />using USDAFoodDB.Models;<br /><br />namespace USDAFoodDB.Context {<br />   public class USDAFoodContext : DbContext {<br />      &hellip;<br />      protected override void OnModelCreating(ModelBuilder modelBuilder) {<br />         base.OnModelCreating(modelBuilder);<br />         <strong>configureEntityFoodDes(modelBuilder);</strong><br />      }<br /><strong><br />      private void configureEntityFoodDes(ModelBuilder mb) {<br />         // PRIMARY KEY<br />         mb.Entity().HasKey(fd =&gt; fd.NdbNo);<br /><br />         // NOT NULL<br />         mb.Entity().Property(fd =&gt; fd.NdbNo).IsRequired();<br />         mb.Entity().Property(fd =&gt; fd.FdGrpCd).IsRequired();<br />         mb.Entity().Property(fd =&gt; fd.LongDesc).IsRequired();<br />         mb.Entity().Property(fd =&gt; fd.ShrtDesc).IsRequired();<br /><br />         // NVARCHAR(x)<br />         mb.Entity().Property(fd =&gt; fd.NdbNo).HasMaxLength(5);<br />         mb.Entity().Property(fd =&gt; fd.FdGrpCd).HasMaxLength(4);<br />         mb.Entity().Property(fd =&gt; fd.LongDesc).HasMaxLength(200);<br />         mb.Entity().Property(fd =&gt; fd.ShrtDesc).HasMaxLength(60);<br />         mb.Entity().Property(fd =&gt; fd.ComName).HasMaxLength(100);<br />         mb.Entity().Property(fd =&gt; fd.ManufacName).HasMaxLength(65);<br />         mb.Entity().Property(fd =&gt; fd.Survey).HasMaxLength(1);<br />         mb.Entity().Property(fd =&gt; fd.RefDesc).HasMaxLength(135);<br />         mb.Entity().Property(fd =&gt; fd.SciName).HasMaxLength(65);<br />      }</strong><br />   }<br />}</code></pre><p>Go ahead and repeat this procedure for the eleven remaining entities.</p><p>Pay close attention to the FOOTNOTE entity and notice that it does not have a principal key. Due to this fact, we will need to add a <strong>shadow property</strong> to represent the principal key. This can be done as follows:</p><pre class="bt-code"><code>using Microsoft.EntityFrameworkCore;<br />using USDAFoodDB.Models;<br /><br />namespace USDAFoodDB.Context {<br />   public class USDAFoodContext : DbContext {<br />      &hellip;<br /><strong>      private void configureEntityFootnote(ModelBuilder mb) {<br />         mb.Entity().Property(&ldquo;FootnoteID&rdquo;);<br />         &hellip;<br />      }</strong><br />   }<br />}</code></pre><p>According to the docs:</p><ul><li><strong>Shadow properties</strong> are properties that are not defined in the .NET entity class but are defined for that entity type in the <em>EF Core</em> model. The value and state of these properties is maintained purely in the <em>Change Tracker</em>.<ul><li><a href="https://docs.microsoft.com/en-us/ef/core/modeling/shadow-properties">See the documentation on shadow properties for more information.</a></li></ul></li></ul><p>Finally, notice that some entities have composite principal-keys and/or composite foreign-keys. For the entities that have composite keys, use the following example to configure them:</p><pre class="bt-code"><code>mb.Entity&lt;Langual&gt;().HasKey(l =&gt; new {l.NdbNo, l.FactorCode});</code></pre><p>To learn more about composite keys, <a href="https://docs.microsoft.com/en-us/ef/core/modeling/relationships">see the Entity Framework Core documentation on relationships.</a></p><p>Now, we are ready to code-in the relationships between the entities.</p><h3>Step 8. Table Relationships &ndash; Finalize the Configurations</h3><p>Again, instead of defining the relationships of each entity, this blog will demonstrate an example of each type of relationship. Since we have already defined and configured <code>FoodDes</code>, we will continue to use it for demonstration. Because these examples are very similar to the relationships between other entities, they can be used as a guide to configure those other relationships.</p><p>Here are the <code>FoodDes</code>&lsquo;s relationships that will be demonstrated:</p><pre class="bt-fmt-txt"><code>1. <strong>ONE</strong>  FOOD_DES (principal) to <strong>MANY</strong> NUT_DATA (dependent)<br />2. <strong>MANY</strong> FOOD_DES (principal) to <strong>MANY</strong> LANGDESC (principal) (intermediary: LANGUAL (dependent))</code></pre><p>The reason these two relationships were chosen is because:</p><ul><li>In #1, FOOD_DES relates to NUT_DATA through a <strong>one-to-many</strong> relationship</li><li>In #2, FOOD_DES relates to LANGDESC through a <strong>many-to-many</strong> relationship</li></ul><p>Let&rsquo;s start with example #1, where FOOD_DES relates to NUT_DATA through a one-to-many relationship.</p><p><span class="bt-underline">One-to-Many</span></p><p>First, let&rsquo;s add the navigation properties to each entity. <a href="https://docs.microsoft.com/en-us/ef/core/modeling/relationships">According to the docs on relationships</a>, a <strong>navigation property</strong> &ldquo;is a property defined on the principal and/or dependent entity that contains a reference(s) to the related entity(s).&rdquo; Basically, what these navigation properties will allow us to do is navigate back and/or forth between two tables when interacting with an instance of some given entity.</p><p>Add the navigation property to <code class="bt-file">FoodDes.cs</code> as follows (note, some code was omitted for brevity):</p><pre class="bt-code"><code><strong>using System.Collections.Generic;<br /><br /></strong>namespace USDAFoodDB.Models {<br />   public class FoodDes {<br />      &hellip;<br />      <strong>public List&lt;NutData&gt; NutDatas { get; set; }</strong><br />   }<br />}</code></pre><p>Now, add the corresponding navigation property to <code class="bt-file">NutData.cs</code> (note, some code was omitted for brevity):</p><pre class="bt-code"><code>namespace App.Models {<br />   public class NutData {<br />      &hellip;<br /><strong>      public FoodDes FoodDes { get; set; }</strong><br />   }<br />}</code></pre><p>Finally, make the following changes, marked in bold, to the <code class="bt-file">USDAFoodContext.cs</code> file (note, some code was omitted for brevity):</p><pre class="bt-code"><code>using Microsoft.EntityFrameworkCore;<br />using USDAFoodDB.Models;<br /><br />namespace USDAFoodDB.Context {<br />   public class USDAFoodContext : DbContext {<br />      &hellip;<br />      private void configureEntityNutData(ModelBuilder mb) {<br />         &hellip;<br />         // RELATIONSHIP: ONE FoodDes TO MANY NutData<br /><strong>         mb.Entity()<br />            .HasOne(nd =&gt; nd.FoodDes)<br />            .WithMany(fd =&gt; fd.NutDatas)<br />            .HasForeignKey(nd =&gt; nd.NdbNo);<br /></strong>      }<br />      &hellip;<br />   }<br />}</code></pre><p>This block of code defines the relationship between FOOD_DES and NUT_DATA as being a one-to-many type of relationship. Additionally, it explicitly defines which property will be serving as a foreign-key. <strong>Note</strong>: the foreign key <code>NdbNo</code> is relative to NUT_DATA.</p><p>Let&rsquo;s move on to example #2, where FOOD_DES relates to LANGDESC through a many-to-many relationship.</p><p><span class="bt-underline">Many-to-Many</span></p><p>The <em>Entity Framework Core</em> does not yet support the creation of many-to-many relationships without an entity class to represent the join table; in other words, it requires an intermediary table. For the relationship in example #2, the intermediary table is named LANGUAL. Furthermore, to create a many-to-many relationship, the <em>Entity Framework Core</em> requires the creation of two one-to-many relationships.</p><p>Let&rsquo;s add the first one-to-many relationship in which we map FOOD_DES to LANGUAL.</p><p>First, add the navigation property to <code class="bt-file">FoodDes.cs</code> as follows (note, some code was omitted for brevity):</p><pre class="bt-code"><code>using System.Collections.Generic;<br /><br />namespace USDAFoodDB.Models {<br />   public class FoodDes {<br />      &hellip;<br />      public List&lt;NutDatas&gt; { get; set; }<br /><strong>      public List&lt;Languals&gt; { get; set; }</strong><br />   }<br />}</code></pre><p>Next, add the corresponding navigation property to <code class="bt-file">Langual.cs</code> (note, some code was omitted for brevity):</p><pre class="bt-code"><code>namespace App.Models {<br />   public class Langual {<br />      &hellip;<br /><strong>      public FoodDes FoodDes { get; set; }</strong><br />   }<br />}</code></pre><p>Finally, make the following changes, marked in bold, to the <code class="bt-file">USDAFoodContext.cs</code> file (note, some code was omitted for brevity):</p><pre class="bt-code"><code>using Microsoft.EntityFrameworkCore;<br /><br />using USDAFoodDB.Models;namespace USDAFoodDB.Context {<br />   public class USDAFoodContext : DbContext {<br />      &hellip;<br />      private void configureEntityLangual(ModelBuilder mb) {<br />         &hellip;<br />         // RELATIONSHIP: ONE FoodDes TO MANY Languals<br /><strong>         mb.Entity&lt;Langual&gt;()<br />            .HasOne(l =&gt; l.FoodDes)<br />            .WithMany(fd =&gt; fd.Languals)<br />            .HasForeignKey(l =&gt; l.NdbNo);<br />      }<br /></strong>      &hellip;<br />   }<br />}</code></pre><p>Now, let&rsquo;s add the second one-to-many relationship where we map LANGDESC to LANGUAL.</p><p>Again, first add the navigation property to <code class="bt-file">LangDesc.cs</code> as follows (note, some code was omitted for brevity):</p><pre class="bt-code"><code><strong>using System.Collections.Generic;</strong><br /><br />namespace USDAFoodDB.Models {<br />   public class LangDesc {<br />      &hellip;<br /><strong>      public List&lt;Langual&gt; Languals { get; set; }</strong><br />   }<br />}</code></pre><p>Then, add the corresponding navigation property to <code class="bt-file">Langual.cs</code> (note, some code was omitted for brevity):</p><pre class="bt-code"><code>namespace App.Models {<br />   public class Langual {<br />      &hellip;<br />      public FoodDes FoodDes { get; set; }<br /><strong>      public LangDesc LangDesc { get; set; }</strong><br />   }<br />}</code></pre><p>Finally, make the following changes, marked in bold, to the <code class="bt-file">USDAFoodContext.cs</code> file (note, some code was omitted for brevity):</p><pre class="bt-code"><code>using Microsoft.EntityFrameworkCore;<br />using USDAFoodDB.Models;<br /><br />namespace USDAFoodDB.Context {<br />   public class USDAFoodContext : DbContext {<br />      &hellip;<br />      private void configureEntityLangual(ModelBuilder mb) {<br />         &hellip;<br />         // RELATIONSHIP: ONE FoodDes TO MANY Languals<br />         mb.Entity&lt;Langual&gt;()<br />            .HasOne(l =&gt; l.FoodDes)<br />            .WithMany(fd =&gt; fd.Languals)<br />            .HasForeignKey(l =&gt; l.NdbNo);<br /><br />         // RELATIONSHIP: ONE LangDesc TO MANY Languals<br /><strong>         mb.Entity&lt;Langual&gt;()<br />            .HasOne(l =&gt; l.LangDesc)<br />            .WithMany(ld =&gt; ld.Languals)<br />            .HasForeignKey(l =&gt; l.FactorCode);<br />      }</strong><br />      &hellip;<br />   }<br />}</code></pre><p>By creating a configuration that maps two one-to-many relationships with a common join table, we were able to create a many-to-many relationship. <a href="https://docs.microsoft.com/en-us/ef/core/modeling/relationships#many-to-many">See the documentation on many-to-many relationships for more information</a>.</p><p>Now that we have demonstrated the creation of two types of relationships in <em>Entity Framework Core</em>: one-to-many and many-to-many, go ahead and use these examples to finish creating the remaining relationships.</p><p>Once the remaining relationships have been created, we will have successfully made <em>Entity Framework Core</em> aware of how the entities in the database are shaped and configured. In the next part (<strong>Part Three</strong>: <a href="blog/recreating-the-usda-national-nutrient-database-using-mssql-on-docker-part-3">Parsing Data and Conclusion</a>), we will finally get the chance to parse the data and store it in the database!</p><h3>What\'s Next?</h3><p>This blog-post is a continuation of <strong>Part 1</strong>: <a href="blog/recreating-the-usda-national-nutrient-database-using-mssql-on-docker-part-1">Foundation and Getting Started</a>. It continues in <strong>Part Three</strong>: <a href="blog/recreating-the-usda-national-nutrient-database-using-mssql-on-docker-part-3">Parsing Data and Conclusion</a>.</p>\n',
  10,
  0
);

export const cdb_aspnet_usda_p3 = new Blog(
  'Recreating the USDA National Nutrient Database Using MSSQL on Docker - Part 3',
  hyphenFn('Recreating the USDA National Nutrient Database Using MSSQL on Docker Part 3'),
  'Hector Lovo',
  'https://lovohh.com',
  'assets/imgs/blog/aspnet_usda/aspnet_usda.png',
  'Backend',
  '05/06/2018',
  '\n' +
  'In part 3 of this blog-series, we wrap up by parsing the data retrieved from the USDA ARS\' website and store it into the MSSQL database. We also make sure to fix some issues that arise in the process. Finally, we add in some code to ensure that we have all of the documented data.',
  '<p><strong>Note to the reader</strong>: because the topic in this blog is discussed a bit in-depth, it has become too long to post in a single blog-post. So, it will be delivered in a multi-part series, composed of three separate blog-posts.</p><p>In case you would like to navigate around the posts, here they are:</p><ul><li><strong>Part One</strong>: <a href="blog/recreating-the-usda-national-nutrient-database-using-mssql-on-docker-part-1">Foundation and Getting Started</a></li><li><strong>Part Two</strong>: <a href="blog/recreating-the-usda-national-nutrient-database-using-mssql-on-docker-part-2">App Configuration</a></li><li><strong>Part Three</strong>: <a href="blog/recreating-the-usda-national-nutrient-database-using-mssql-on-docker-part-3">Parsing Data and Conclusion</a></li></ul><h2>Parsing Data</h2><p>Now, we are ready to parse the data into the database but before we do, first, we will need to update the connection-string so that it uses the following database: <code>USDAFoodAPI</code>. Also, instead of using a <code>SqlConnection</code>, we will use the <code>USDAFoodContext</code> that we created in <strong>Step 6. Table Relationships &ndash; DbContext</strong> in <strong>Part Two</strong>: <a href="blog/recreating-the-usda-national-nutrient-database-using-mssql-on-docker-part-2">App Configuration</a>.</p><h3>Step 9. Connect to the MSSQL-Server Through DbContext</h3><p>In <code class="bt-file">./USDAFoodDB/Program.cs</code>, make the following changes, marked in bold:</p><pre class="bt-code"><code><strong>using Microsoft.EntityFrameworkCore;<br />using USDAFoodDB.Context;</strong><br /><br />namespace USDAFoodDB {<br />   class Program {<br /><strong>      private const string ConnString = "Server=localhost,1433;Database=USDAFoodAPI;"<br />    \t\t\t\t      + "User Id=sa;Password=password123!;"<br />                                      + "MultipleActiveResultSets=true";</strong><br />      static void Main() {<br /><strong>         var optionsBuilder = new DbContextOptionsBuilder&lt;USDAFoodContext&gt;();<br />         optionsBuilder.UseSqlServer(ConnString);<br /><br />         using (var context = new USDAFoodContext(optionsBuilder.Options)) {<br />            <br />         }</strong><br />      }<br />   }<br />}</code></pre><h3>Step 10. Read the Data Text-Files</h3><p>To maintain a clean code-structure, let&rsquo;s add the following files to the <code class="bt-dir">./USDAFoodDB/Tools/</code> directory:</p><ul><li><code class="bt-file">Common.cs</code> &ndash; will house commonly used methods</li><li><code class="bt-file">DataInitializer.cs</code> &ndash; will house methods used to read the data  and methods to place that data into the database</li></ul><p>Starting with <code class="bt-file">./USDAFoodDB/Tools/Common.cs</code> file, add the following method, marked in bold:</p><pre class="bt-code"><code>using System.Collections.Generic;<br /><br />namespace USDAFoodDB.Tools {<br />   public class Common {<br /><strong>      public static List&lt;string[]&gt; ReadFilepath(string filePath) {<br />         System.IO.StreamReader fileReader = new System.IO.StreamReader(filePath);<br />         List&lt;string[]&gt; dataList = new List&lt;string[]&gt;();<br />         string line;<br /><br />         while ((line = fileReader.ReadLine()) != null) {<br />            dataList.Add(line.Replace(&ldquo;~&rdquo;, &ldquo;&rdquo;).Split("^"));<br />         }<br /><br />         fileReader.Close();<br />         return dataList;<br />      }</strong><br />   }<br />}</code></pre><p>The <code>ReadFilePath(...)</code> method accepts a file-path through the <code>string</code> parameter named <code>filePath</code>. It also returns a <code>list of an array of strings</code>. Each <code>array of string</code> contains a particular entity&rsquo;s data.</p><p>Let\'s use the data retrieved from the <code>ReadFilePath(...)</code> method to create instances of the models we created in <strong>Step 4. Create the Models</strong> in <strong>Part Two</strong>: <a href="blog/recreating-the-usda-national-nutrient-database-using-mssql-on-docker-part-2">App Configuration</a>. Again, instead of showing how to create instances of each entity, this blog will only show how to create an instance of <code>FoodDes</code>. The remaining models can be created by following a similar pattern.</p><p>Add the following code into the <code class="bt-file">./USDAFoodDB/Tools/DataInitializer.cs</code> file:</p><pre class="bt-code"><code>using System;<br />using System.Collections.Generic;<br />using USDAFoodDB.Context;<br />using USDAFoodDB.Models;<br /><br />namespace USDAFoodDB.Tools {<br />   public class DataInitializer {<br />      private const string DATA_FILEPATH = "./Src/SR-Leg_ASC";<br /><br />      private static void Init_FoodDes(USDAFoodContext context) {<br />         List&lt;string[]&gt; dataList = Common.ReadFilepath(DATA_FILEPATH + "/FOOD_DES.txt");<br />         List&lt;FoodDes&gt; foodDeses = new List&lt;FoodDes&gt;();<br /><br />         foreach (string[] datapoint in dataList) {<br />            foodDeses.Add(new FoodDes() {<br />               NdbNo = datapoint[0],<br />               FdGrpCd = datapoint[1],<br />               LongDesc = datapoint[2],<br />               ShrtDesc = datapoint[3],<br />               ComName = datapoint[4],<br />               ManufacName = datapoint[5],<br />               Survey = datapoint[6],<br />               RefDesc = datapoint[7],<br />               Refuse = string.IsNullOrEmpty(datapoint[8]) ? 0 : Convert.ToInt32(datapoint[8]),<br />               SciName = datapoint[9],<br />               NFactor = string.IsNullOrEmpty(datapoint[10]) ? 0.0 : Convert.ToDouble(datapoint[10]),<br />               ProFactor = string.IsNullOrEmpty(datapoint[11]) ? 0.0 : Convert.ToDouble(datapoint[11]),<br />               FatFactor = string.IsNullOrEmpty(datapoint[12]) ? 0.0 : Convert.ToDouble(datapoint[12]),<br />               ChoFactor = string.IsNullOrEmpty(datapoint[13]) ? 0.0 : Convert.ToDouble(datapoint[13])<br />            });<br />         }<br />      }<br />   }<br />}</code></pre><p>This code simply reads the <code class="bt-file">FOOD_DES.txt</code> file, creates all the instances of the <code>FoodDes</code> entity, and stores them in the <code>foodDeses</code> list. Now, we need a way to insert these entities into the database.</p><p>To add the entities into the database, we could simply take the <code>foodDeses</code> list and pass it through the <code>USDAFoodContext</code>&rsquo;s <code>AddRange(...)</code> method, like so:</p><pre class="bt-code"><code>context.AddRange(foodDeses);</code></pre><p>This was the approach I initially tried but quickly ran into some performance issues - due to the large amount of data - where it would take a long time to insert the data into the database. Not to mention, some of the data would fail to be inserted &ndash; without warning.</p><p>So, after quickly searching for another solution, I came upon a blog-post about <a href="https://www.djamseed.com/2015/08/31/improving-bulk-insert-performance-with-entity-framework/">Improving Bulk Insert Performance with Entity Framework</a>.</p><h3>Step 11. Store the Data into the Database &ndash; Bulk Insert</h3><p>Essentially, the solution to inserting large amounts of data is to insert the data in batches. So, let&rsquo;s extend the <code>USDAFoodContext</code> so that it can insert data in batches.</p><p>Create the file <code class="bt-file">./USDAFoodDB/Context/USDAFoodContextExtensions.cs</code> and add the following code to it:</p><pre class="bt-code"><code>using System;<br /><br />namespace USDAFoodDB.Context {<br />   public static class USDAFoodContextExtensions {<br />      public static USDAFoodContext BulkInsert&lt;T&gt;(this USDAFoodContext context, T entity, int count, int batchSize)<br />         where T : class {<br />         context.Set&lt;T&gt;().Add(entity);<br /><br />         if (count % batchSize == 0) {<br />            context.SaveChanges();<br />            context.Dispose();<br />            context = new USDAFoodContext(context.DbContextOptions);<br />         }<br /><br />         return context;<br />      }<br />   }<br />}</code></pre><p><code>BulkInsert&lt;T&gt;(...)</code> is a generic method that returns a new <code>USDAFoodContext</code> and accepts three parameters:</p><ol><li><code>entity</code>: the entity being inserted &ndash; of generic type <code>T</code>. This is used to carry the data to be inserted into the database.</li><li><code>count</code>: the current count &ndash; of type <code>int</code>. This is used to keep track of how many entities exist in the batch.</li><li><code>batchSize</code>: the cutoff count &ndash; of type <code>int</code>. This is used to determine when to store the current batch into the database and start a new batch.</li></ol><p>The method <code>BulkInsert&lt;T&gt;(...)</code> simply adds an instance of an entity, that has been passed through the parameter named <code>entity</code>, into the context named <code>context</code>. Once the count has reached the <code>batchSize</code> delimiter, <code>BulkInsert&lt;T&gt;(...)</code> stores the data it has accumulated in the current context into the database.</p><p>To use <code>BulkInsert&lt;T&gt;(...)</code>, let&rsquo;s create a separate method that will manage the count, independently. So, back in <code class="bt-file">./USDAFoodDB/Tools/DataInitializer.cs</code>, add the following code marked in bold (note, some code was omitted for brevity):</p><pre class="bt-code"><code>using System;<br />using System.Collections.Generic;<br />using USDAFoodDB.Context;<br />using USDAFoodDB.Models;<br /><br />namespace USDAFoodDB.Tools {<br />   public class DataInitializer {<br /><strong>      private const int BATCH_SIZE_DELIM = 1000;<br /></strong>      private const string DATA_FILEPATH = "./Src/SR-Leg_ASC";<br /><br /><strong>      private static void AddToDatabase&lt;T&gt;(USDAFoodContext originalContext, ref List&lt;T&gt; objs, int batchSize = BATCH_SIZE_DELIM)<br />         where T : class {<br />         USDAFoodContext context;<br /><br />         using (context = new USDAFoodContext(originalContext.DbContextOptions)) {<br />            int count = 0;<br /><br />            foreach (T obj in objs) {<br />               count = count + 1;<br />               context = context.BulkInsert(obj, count, batchSize);<br />            }<br /><br />            context.SaveChanges();<br />         }<br />      }<br /></strong>      &hellip;<br />   }<br />}</code></pre><p>Each time <code>AddToDatabase&lt;T&gt;(...)</code> is called, it creates a new session with the database and then proceeds to store the instances of entities (named <code>objs</code> in the parameter list of the method), in batches, into the database.</p><p>All we need to do is call <code>AddToDatabase&lt;T&gt;(...)</code> from <code>Init_FoodDes(...)</code> and we are all set. So, let&rsquo;s update the <code>Init_FoodDes(...)</code> method like follows (note, some code was omitted for brevity):</p><pre class="bt-code"><code>using System;<br />using System.Collections.Generic;<br />using USDAFoodDB.Context;using USDAFoodDB.Models;<br /><br />namespace USDAFoodDB.Tools {<br />   public class DataInitializer {<br />      &hellip;<br />      private static void Init_FoodDes(USDAFoodContext context) {<br />         List&lt;string[]&amp;tt; dataList = Tools.Common.ReadFilepath(DATA_FILEPATH + "/FOOD_DES.txt");<br />         List&lt;FoodDes&gt; foodDeses = new List&lt;FoodDes&gt;();<br /><br />         foreach (string[] datapoint in dataList) {<br />            foodDeses.Add(new FoodDes() { &hellip; });<br />         }<br /><br /><strong>         AddToDatabase(context, ref foodDeses);</strong><br />      }<br />   }<br />}</code></pre><p>The remaining entities can be added to the database by following a similar pattern; that is:</p><ul><li>Read the text-file containing pertinent data (from<strong> Step 10. Read the Data Text-Files</strong>)</li><li>Convert that data into an entity (again, see <strong>Step 10. Read the Data Text-Files</strong>)</li><li>Pass the entities to the database (as we did in this step)</li></ul><p>At this point, we are ready to tie everything together and complete the app.</p><h3>Step 12. Wrap Up</h3><p>In <code class="bt-file">./USDAFoodDB/Tools/DataInitializer.cs</code>, let\'s call all of the methods we just created from the following <code>Initialize(...)</code> method (note, some code was omitted for brevity):</p><pre class="bt-code"><code>using System;<br />using System.Collections.Generic;<br /><strong>using System.Linq;</strong><br />using USDAFoodDB.Context;<br />using USDAFoodDB.Models;<br /><br />namespace USDAFoodDB.Tools {<br />   public class DataInitializer {<br />      &hellip;<strong><br />      public static void Initialize(USDAFoodContext context) {<br />         context.Database.EnsureDeleted();<br />         context.Database.EnsureCreated();<br /><br />         if (!context.FdGroups.Any()) {<br />            Init_FdGroups(context);<br />         }<br /><br />         if (!context.LangDescs.Any()) {<br />            Init_LangDesc(context);<br />         }<br /><br />         if (!context.FoodDeses.Any()) {<br />            Init_FoodDes(context);<br />         }<br /><br />         if (!context.Languals.Any()) {<br />            Init_Langual(context);<br />         }<br /><br />         if (!context.Footnotes.Any()) {<br />            Init_Footnote(context);<br />         }<br /><br />         if (!context.Weights.Any()) {<br />            Init_Weight(context);<br />         }<br /><br />         if (!context.DerivCds.Any()) {<br />            Init_DerivCd(context);<br />         }<br /><br />         if (!context.SrcCds.Any()) {<br />            Init_SrcCd(context);<br />         }<br /><br />         if (!context.NutrDefs.Any()) {<br />            Init_NutrDef(context);<br />         }<br /><br />         if (!context.DataSrcs.Any()) {<br />            Init_DataSrc(context);<br />         }<br /><br />         if (!context.NutDatas.Any()) {<br />            Init_NutData(context);<br />         }<br /><br />         if (!context.DatSrcLns.Any()) {<br />            Init_DataSrcLn(context);<br />         }<br />      }</strong><br />   }<br />}</code></pre><p>Recall, from <strong>Step 5. Table Relationships &ndash; Definitions</strong> in <strong>Part Two</strong>: <a href="blog/recreating-the-usda-national-nutrient-database-using-mssql-on-docker-part-2">App Configuration</a>, that the database insertion order does matter. The principal entities should be added to the database before their corresponding, dependent entities. If the data is not inserted in this fashion, the database will return an insert error.</p><p>Also, notice that we ensure that we reset the database before inserting any data by calling the methods <code>context.Database.EnsureDeleted()</code> and <code>context.Database.EnsureCreated()</code>. This is so that we start with an empty database each time we run the code. More on this later.</p><p>Next, let&rsquo;s call this Initialize method from <code class="bt-file">./USDAFoodDB/Program.cs</code>:</p><pre class="bt-code"><code>using Microsoft.EntityFrameworkCore;<br />using USDAFoodDB.Context;<br /><br />namespace USDAFoodDB {<br />   class Program {<br />      private const string ConnString = "Server=localhost,1433;Database=USDAFoodAPI;"<br />                                      + "User Id=sa;Password=password123!;"<br />                                      + "MultipleActiveResultSets=true";<br /><br />      static void Main(string[] args) {<br />         var optionsBuilder = new DbContextOptionsBuilder&lt;USDAFoodContext&gt;();<br />         optionsBuilder.UseSqlServer(ConnString);<br /><br />         using (var context = new USDAFoodContext(optionsBuilder.Options)) {<br /><strong>            Tools.DataInitializer.Initialize(context);</strong><br />         }<br />      }<br />   }<br />}</code></pre><p>That&rsquo;s it! That&rsquo;s all we needed to do to parse the data and insert it into the database. Or is it?</p><p>Let&rsquo;s go ahead and run the console-app by opening the terminal (<code>t1</code>) window and running the following command:</p><pre class="bt-cmd-in"><code>dotnet run</code></pre><p>The app crashes and reports an error. Not quite what we were expecting. Let&rsquo;s look into this matter a bit.</p><h3>Step 13. Fix the Text-Files</h3><p>After running the app, we ran into the following issue (note, some error text-output was omitted for brevity):</p><pre class="bt-cmd-out"><code>Unhandled Exception: System.IndexOutOfRangeException: Index was outside the bounds of the array.<br /><br />   at USDAFoodDB.Tools.DataInitializer.Init_DerivCd(USDAFoodContext context) in DataInitializer.cs:line 137<br />   at USDAFoodDB.Tools.DataInitializer.&lt;&gt;c__DisplayClass15_0.&lt;Initialize&gt;b__6() in DataInitializer.cs:line 273<br />&hellip;<br /></code></pre><p>According to this output, we ran into an <code>IndexOutOfRangeException</code>.</p><p>The stack trace points to a problem in <strong>line 137</strong> in the <code class="bt-file">DataInitializer.cs</code> file. We see the following code in that vicinity:</p><pre class="bt-code"><code>&hellip;<br />#132 private static void Init_DerivCd(USDAFoodContext context) {<br />#133   List&lt;string[]&gt; dataList = Common.ReadFilepath(DATA_FILEPATH + "/DERIV_CD.txt");<br />#134   List&lt;DerivCd&gt; derivCds = new List&lt;DerivCd&gt;();<br />#135\t<br />#136   foreach (string[] datapoint in dataList) {<br /><strong>#137\t  derivCds.Add(new DerivCd() {<br />#138\t      Deriv_Cd = datapoint[0],<br />#139\t      DerivDesc = datapoint[1]<br />#140\t  });<br />#141   }</strong><br />#142\t<br />#143   AddToDatabase(context, ref derivCds);<br />#144 }<br />&hellip;<br /></code></pre><p>As can be seen, the issue stems from when we attempt to access the <code>datapoint</code> string array. We expected two elements but received less than two; hence the <code>IndexOutOfRangeException</code>. We know that the <code>ReadFilePath(...)</code> method worked for the other entities so let&rsquo;s rule that out for now and start off by looking at the text-data file: <code class="bt-file">DERIV_CD.txt</code>.</p><p>The first thing that&rsquo;s evident in the text-data file <code class="bt-file">DERIV_CD.txt</code>, that was downloaded directly from the USDA, is that <strong>line 39</strong> is on its own line when it should be a part of <strong>line 38</strong> (in other words, not our app&rsquo;s fault). Let&rsquo;s fix this issue by moving <strong>line 39</strong> to the end of <strong>line 38</strong> in the text-data file.</p><p>Now we are done, correct? Let&rsquo;s find out by running the following command once again:</p><pre class="bt-cmd-in"><code>dotnet run</code></pre><p>Now, we run into a second issue (note, some error text-output was omitted for brevity):</p><pre class="bt-cmd-out"><code>Unhandled Exception: Microsoft.EntityFrameworkCore.DbUpdateException: An error occurred while updating the entries. <br /><br />See the inner exception for details. ---&gt; System.Data.SqlClient.SqlException: The INSERT statement conflicted with the FOREIGN KEY constraint "FK_DataSrcLns_NutDatas_NdbNo_NutrNo". <br /><br />The conflict occurred in database "USDAFoodAPI", table "dbo.NutDatas".<br />The statement has been terminated.<br />&hellip;<br />   at Microsoft.EntityFrameworkCore.DbContext.SaveChanges(Boolean acceptAllChangesOnSuccess)<br />   at USDAFoodDB.Context.USDAFoodContextExtensions.BulkInsert[T](USDAFoodContext context, T entity, Int32 count, Int32 batchSize) in USDAFoodContextExtensions.cs:line 10<br />   at USDAFoodDB.Tools.DataInitializer.AddToDatabase[T](USDAFoodContext originalContext, List`1&amp; objs, Int32 batchSize) in DataInitializer.cs:line 20<br />   at USDAFoodDB.Tools.DataInitializer.Init_DataSrcLn(USDAFoodContext context) in DataInitializer.cs:line 240<br />   at USDAFoodDB.Tools.DataInitializer.&lt;&gt;c__DisplayClass15_0.&lt;Initialize&gt;b__11() in DataInitializer.cs:line 293<br />&hellip;<br /></code></pre><p>According to this error-output, we have a <code>DbUpdateException</code>.</p><p>The stack trace points to a problem in <strong>line 10</strong> in the <code class="bt-file">USDAFoodContextExtensions.cs</code> file. We see the following code in that vicinity:</p><pre class="bt-code"><code>&hellip;<br />#5  public static USDAFoodContext BulkInsert&lt;T&gt;(this USDAFoodContext context, T entity, int count, int batchSize)<br />#6      where T : class {<br />#7      context.Set&lt;T&gt;().Add(entity);<br />#8 <br />#9      if (count % batchSize == 0) {<br /><strong>#10         context.SaveChanges();</strong><br />#11         context.Dispose();<br />#12         context = new USDAFoodContext(context.DbContextOptions);<br />#13<br />#14         Console.WriteLine("--&gt; UPDATED DB: " + count + " ... ");<br />#15     }<br />#16<br />#17     return context;<br />#18 }<br />&hellip;</code></pre><p>As can be seen in the error-output, the issue stems from a violation of the foreign-key constraint between DATSRCLN and NUT_DATA when attempting to insert an instance of DATASRCLN:  </p><pre class="bt-cmd-out"><code>... SqlException: The INSERT statement conflicted with the FOREIGN KEY constraint "FK_DataSrcLns_NutDatas_NdbNo_NutrNo".</code></pre><p>Let&rsquo;s briefly review the relationship between DATSRCLN and NUT_DATA:</p><pre class="bt-fmt-txt"><code><strong>MANY</strong> NUT_DATA (principal) to <strong>MANY</strong> DATA_SRC (principal) (intermediary: DATSRCLN (dependent))</code></pre><p>We have a many-to-many relationship between NUT_DATA and DATASRC but we know <em>Entity Framework Core</em> requires two one-to-many relationships to create a many-to-many relationship.</p><p>So, let&rsquo;s focus on the one-to-many relationship causing the issue (we know this from the error-output):</p><pre class="bt-fmt-txt"><code><strong>MANY</strong> NUT_DATA (principal) to <strong>ONE</strong> DATASRCLN (dependent)</code></pre><p>Since DATSRCLN is the dependent table, this indicates that an instance of the values that compose the foreign-key have to also exist in NUT_DATA before we are able to insert that instance into DATASRCLN. Given the error-output we received, it is evident that this condition was not met. Simply put, we tried to insert values into DATSRCLN that do not correspond to any values in NUT_DATA. How do we fix this issue?</p><h3>Step 14. Omit Unused DATASRCLN Records</h3><p>To fix this issue, we will have to ensure that for each instance of DATASRCLN, there exists an instance of NUTDATA. If there exists a case in which an instance of DATSRCLN exists but no corresponding instance of NUTDATA exists, we will have to remove that DATSRCLN data.</p><p>How can this be accomplished?</p><p>Instead of changing the current code and adding unnecessary complexity, let&rsquo;s add a simple method that handles this issue before we parse the data.</p><p>Let&rsquo;s start off by adding the file <code class="bt-file">./USDAFoodDB/Tools/DataCorrection.cs</code> and modifying it to look like the following:</p><pre class="bt-code"><code>using System;<br />using System.Collections.Generic;<br />using System.Text;<br /><br />namespace USDAFoodDB.Tools {<br />   public class DataCorrection {<br />      public static void FixDatSrcLnRecords() {<br />         const string srcDirectoryFilePath = "./Src/SR-Leg_ASC/";<br />         const string datasrclnFilepath = srcDirectoryFilePath + "DATSRCLN.txt";<br />         const string nutdataFilepath = srcDirectoryFilePath + "NUT_DATA.txt";<br />         const string newDatasrclnFilepath = srcDirectoryFilePath + "DATSRCLN.fixed.txt";<br /><br />         if (System.IO.File.Exists(newDatasrclnFilepath)) {<br />            Console.WriteLine(newDatasrclnFilepath + " already exists.");<br />            return;<br />         }<br /><br />         List&lt;string[]&gt; datasrclnList = Common.ReadFilepath(datasrclnFilepath);<br />         List&lt;string[]&gt; nutdataList = Common.ReadFilepath(nutdataFilepath);<br />         Dictionary&lt;string, SortedSet&lt;string&gt;&gt; nutdataDictionary = new Dictionary&lt;string, SortedSet&lt;string&gt;&gt;();<br />         string ndbNo;<br />         string nutrNo;<br /><br />         foreach (string[] nutdataRow in nutdataList) {<br />            ndbNo = nutdataRow[0];<br />            nutrNo = nutdataRow[1];<br /><br />            if (!nutdataDictionary.ContainsKey(ndbNo)) {<br />               nutdataDictionary[ndbNo] = new SortedSet&lt;string&gt;();<br />            }<br /><br />            nutdataDictionary[ndbNo].Add(nutrNo);<br />         }<br /><br />         StringBuilder sb = new StringBuilder();<br />         int invalidDataCount = 0;<br /><br />         foreach (string[] datasrclnStrings in datasrclnList) {<br />            ndbNo = datasrclnStrings[0];<br />            nutrNo = datasrclnStrings[1];<br /><br />            if (!nutdataDictionary.ContainsKey(ndbNo) || !nutdataDictionary[ndbNo].Contains(nutrNo)) {<br />               invalidDataCount++;<br />               continue;<br />            }<br /><br />            sb.Append(string.Join("^", datasrclnStrings) + "\\n");<br />         }<br /><br />         using (System.IO.StreamWriter file = new System.IO.StreamWriter(newDatasrclnFilepath)) {<br />            file.Write(sb.ToString());<br />         }<br />      }<br />   }<br />}</code></pre><p>To quickly summarize this code, it simply:</p><ul><li>Determines if the <code class="bt-file">./USDAFoodDB/Src/SR-Leg_ASC/DATSRCLN.fixed.txt</code> file already exists. If it finds that it does exist, it does nothing</li><li>Reads the text-file data for both NUT_DATA and DATSRCLN</li><li>Determines if data from DATSRCLN has a corresponding row in NUT_DATA (a <code>Dictionary</code> is used for quick reference)</li><li>If the DATSRCLN data does not have a corresponding row in NUT_DATA, then it is removed</li><li>Finally, the fixed set of data is written to the file <code class="bt-file">./USDAFoodDB/Src/SR-Leg_ASC/DATSRCLN.fixed.txt</code></li></ul><p>Now, we need to update the code so that it calls the method <code>FixDatSrcLnRecords()</code> and reads from the newly fixed data-file <code class="bt-file">./USDAFoodDB/Src/SR-Leg_ASC/DATSRCLN.fixed.txt</code>. We can do so by making the following edits, marked in bold, to <code class="bt-file">./USDAFoodDB/Tools/DataInitializer.cs</code> (note, some code was omitted for brevity):</p><pre class="bt-code"><code>&hellip;<br />private static void Init_DataSrcLn(USDAFoodContext context) {<br /><strong>   List&lt;string[]&gt; dataList = Common.ReadFilepath(DATA_FILEPATH + "/DATSRCLN.fixed.txt");</strong><br />   List&lt;DataSrcLn&gt; dataSrcLns = new List&lt;DataSrcLn&gt;();<br />   &hellip;<br />}<br />&hellip;<br />public static void Initialize(USDAFoodContext context) {<br />   <strong>DataCorrection.FixDatSrcLnRecords();</strong><br />   &hellip;<br />}<br />&hellip;<br /></code></pre><p>Let&rsquo;s find out if this fixed our issue by running following command one more time:</p><pre class="bt-cmd-in"><code>dotnet run</code></pre><p>Success!</p><p>We find that our newly added method <code>FixDataSrcLnRecords()</code> removes <strong>119 data-records</strong> from DATSRCLN because they do not have corresponding data in NUT_DATA.</p><p>Everything appears to be working well but let&rsquo;s ensure that we have all of the data that the documentation indicates we should have.</p><h3>Step 15. Ensure the Data&rsquo;s in the Database</h3><p>To ensure we have all of the data, let&rsquo;s create a method that counts how many entities exist per table. If we have the correct count, we can assume that we have all of the data. The only exception will be DATSRCLN, since we removed 119 records. So, for that case, we will take the documentation&rsquo;s expected count and subtract 119 from it.</p><p>Let&rsquo;s start by adding a helper-method to <code class="bt-file">./USDAFoodDB/Tools/DataInitializer.cs</code>:</p><pre class="bt-code"><code>private static bool EnsureTable(int expected, int result, string tableName) {<br />   if (expected != result) {<br />      Console.WriteLine(tableName + ": expected " + expected + <br /> \t\t      " but got " + result + " instead");<br />   } else {<br />      Console.WriteLine("Successfully completed: " + tableName);<br />   }<br /><br />   return expected == result;<br />}</code></pre><p>This method returns a <code>bool</code> and takes three parameters:</p><ul><li><code>expected</code>: the count retrieved from the documentation &ndash; type <code>int</code></li><li><code>result</code>: the count retrieved from the database &ndash; type <code>int</code></li><li><code>tableName</code>: the table&rsquo;s name &ndash; type <code>string</code></li></ul><p>If the counts are not equal, this method outputs a pertinent message to the console and returns false.</p><p>Next, let&rsquo;s use the <code>EnsureTable()</code> method for each entity, within the <code>EnsureCorrectDataEntry(...)</code> method, in <code class="bt-file">./USDAFoodDB/Tools/DataInitializer.cs</code>:</p><pre class="bt-code"><code>&hellip;<br />public static void EnsureCorrectDataEntry(USDAFoodContext context) {<br />   bool dataSrcValidCount = EnsureTable(606, context.DataSrcs.Count(), "DATA_SRC");<br />   bool dataSrcLnValidCount = EnsureTable(228457 - 119, context.DatSrcLns.Count(), "DATSRCLN");<br />   bool derivCdValidCount = EnsureTable(56, context.DerivCds.Count(), "DERIV_CD");<br />   bool fdGroupValidCount = EnsureTable(25, context.FdGroups.Count(), "FD_GROUP");<br />   bool foodDesValidCount = EnsureTable(7793, context.FoodDeses.Count(), "FOOD_DES");<br />   bool footnoteValidCount = EnsureTable(537, context.Footnotes.Count(), "FOOTNOTE");<br />   bool langDescValidCount = EnsureTable(773, context.LangDescs.Count(), "LANGDESC");<br />   bool langualValidCount = EnsureTable(37910, context.Languals.Count(), "LANGUAL");<br />   bool nutDataValidCount = EnsureTable(644125, context.NutDatas.Count(), "NUT_DATA");<br />   bool nutrDefValidCount = EnsureTable(149, context.NutrDefs.Count(), "NUTR_DEF");<br />   bool srcCdValidCount = EnsureTable(10, context.SrcCds.Count(), "SRC_CD");<br />   bool weightValidCount = EnsureTable(14449, context.Weights.Count(), "WEIGHT");<br />   bool validCounts = dataSrcValidCount &amp;&amp; dataSrcLnValidCount &amp;&amp; derivCdValidCount<br />                  &amp;&amp; fdGroupValidCount &amp;&amp; foodDesValidCount &amp;&amp; footnoteValidCount<br />                  &amp;&amp; langDescValidCount &amp;&amp; langualValidCount &amp;&amp; nutDataValidCount<br />                  &amp;&amp; nutrDefValidCount &amp;&amp; srcCdValidCount &amp;&amp; weightValidCount;<br /><br />   Console.WriteLine(validCounts ? "Successfully completed operation!" : "Failed to complete operation!");<br />}<br />&hellip;</code></pre><p>This code-block simply compares the expected-count, retrieved from the documentation, to the actual-count, retrieved from the database, for each entity. If any of them do not meet this condition, the console outputs an error-message. <strong>Note</strong>: for DATSRCLN, we subtract 119 from 228,457.</p><p>Let&rsquo;s connect this method to the <code class="bt-file">./USDAFoodDB/Program.cs</code> file by adding the following line, highlighted in bold:</p><pre class="bt-code"><code>using Microsoft.EntityFrameworkCore;<br />using USDAFoodDB.Context;<br /><br />namespace USDAFoodDB {<br />   class Program {<br />      private const string ConnString = "Server=localhost,1433;Database=USDAFoodAPI;" +<br />                                "User Id=sa;Password=password123!;" +<br />                                "MultipleActiveResultSets=true";<br />      static void Main(string[] args) {<br />         var optionsBuilder = new DbContextOptionsBuilder&lt;USDAFoodContext&gt;();<br />         optionsBuilder.UseSqlServer(ConnString);<br /><br />         using (var context = new USDAFoodContext(optionsBuilder.Options)) {<br />            Tools.DataInitializer.Initialize(context);<br /><strong>            Tools.DataInitializer.EnsureCorrectDataEntry(context);</strong><br />         }<br />      }<br />   }<br />}</code></pre><p>It should be noted that at this point the following line, marked in bold, in the file <code class="bt-file">./USDAFoodDB/Tools/DataInitializer.cs</code> can be commented out:</p><pre class="bt-code"><code>using System;<br />using System.Collections.Generic;<br />using USDAFoodDB.Context;using USDAFoodDB.Models;<br /><br />namespace USDAFoodDB.Tools {<br />   public class DataInitializer {<br />      &hellip;<br />      public static void Initialize(USDAFoodContext context) {<br />         DataCorrection.FixDatSrcLnRecords();<br /><strong>         // context.Database.EnsureDeleted();</strong><br />         context.Database.EnsureCreated();<br />\t &hellip;<br />      }<br />   }<br />}</code></pre><p>Since we know that the database has been successfully created, there\'s no need to waste computing-resources recreating it each time we run the code, now. By commenting-out <code>context.Database.EnsureDeleted()</code>, we skip over most of the code and straight into the <code>EnsureCorrectDataEntry(...)</code> method.</p><p>Let&rsquo;s run the code one last time to verify the data by running the following command:</p><pre class="bt-cmd-in"><code>dotnet run</code></pre><p>If everything ran accordingly, one should see the following output:</p><pre class="bt-cmd-out"><code>Successfully completed: DATA_SRC<br />Successfully completed: DATSRCLN<br />Successfully completed: DERIV_CD<br />Successfully completed: FD_GROUP<br />Successfully completed: FOOD_DES<br />Successfully completed: FOOTNOTE<br />Successfully completed: LANGDESC<br />Successfully completed: LANGUAL<br />Successfully completed: NUT_DATA<br />Successfully completed: NUTR_DEF<br />Successfully completed: SRC_CD<br />Successfully completed: WEIGHT<br />Successfully completed operation!</code></pre><h3>Step 16. Convert Into Docker Image </h3><p>Now, we are ready to save all of the work we have done so far into a more permanent form, a <em>Docker image.</em></p><p>Currently, we have a <em>MSSQL Docker container</em> &ndash; named <code>mssql-usdafooddb</code> &ndash; running, with all of the work that needs to be saved. To be able to save this work into an image, let&rsquo;s run the following command:</p><pre class="bt-cmd-in"><code>docker commit mssql-usdafooddb mssql-usdafooddb:latest</code></pre><p>By calling docker commit, we are creating a new image from the running-container named <code>mssql-usdafooddb</code>. In this case, we are also:</p><ul><li>Naming the image <code>mssql-usdafooddb</code></li><li>Tagging that image with a <code>latest</code> tag</li></ul><p>Now, to verify if the previous command ran successfully, run the following command:</p><pre class="bt-cmd-in"><code>docker images</code></pre><p>If everything worked out, we should see something like the following output-text:</p><pre class="bt-cmd-out"><code>REPOSITORY\t\tTAG\tIMAGE ID\tCREATED\t\tSIZE<br />mssql-usdafooddb\tlatest\tb8ee8ecb2a5f    2 minutes ago\t2.25GB</code><code></code></pre><h3>Conclusion</h3><p>This blog demonstrated the creation of a <em>Docker image</em> containing a database filled with reliable nutrition-data. For convenience, it was also uploaded to <em>Docker-Hub</em> and given public access. From here on out, all we need to do is pull down the image <code>lovohh/mssql-usdafooddb:latest</code> from <em>Docker-Hub</em> to be able to use it in any future app.</p><p>Once again, it should be noted, that the origin of this data has been deemed reliable enough to be used by those in government &ndash; to help set dietary standards &ndash; those in academia &ndash; to help out with research &ndash; and those in the private sector &ndash; to assist in product development.</p><p>It should also be noted, as was mentioned in the introduction of this series, you have the option to simply use the API provided by the USDA. But, be aware that the decision to use the API does come with some tradeoffs. On the other hand, if you decide to use the <em>Docker image</em> in this blog, you will need to create your own API to make the data more easily accessible to other apps.</p><h3>What\'s Next?</h3><p>In a future blog, we will be creating a relatively small app that will use <code>lovohh/mssql-usdafooddb:latest</code>. This implies that we will also be creating an API for this database so that the app can easily access the data.</p><p>The next app will simply determine the acidity of some food item using a formula developed by the USDA, named <em>Potential Renal Acid Load</em> or PRAL, for short. It will be a relatively small app but it will allow the opportunity to see how this <em>Docker image</em> can be used.</p><p>This blog-post is a continuation of <strong>Part Two</strong>: <a href="blog/recreating-the-usda-national-nutrient-database-using-mssql-on-docker-part-2">App Configuration</a> and is the final post in the series.</p>\n',
  12,
  0
);
