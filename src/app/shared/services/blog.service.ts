import { Injectable } from '@angular/core';
import { Blog } from '../class';

@Injectable()
export class BlogService {
  blogsArr: Blog[];
  blogs: { [snakedTitle: string]: number };

  constructor() {
    const hyphenFn = function (txt) {
      return txt.replace(/\s+/g, '-').toLowerCase();
    };

    this.blogsArr = [
      new Blog(
        'Getting Started with CockroachDB + Docker',
        hyphenFn('Getting Started with CockroachDB + Docker'),
        'Hector Lovo',
        'https://lovohh.com',
        'assets/imgs/blog/gswcdbd/gswcdbd_banner.png',
        'Backend',
        '04/07/2018',
        'CockroachDB combines scalability with the traditional SQL language we have accustomed ourselves to know. This allows programmers to continue to be productive at writing well-structured queries all while automatically making data always-available through redundancy.',
        '<div><p>In today&rsquo;s fast-paced, tech-world, having the ability to switch an online-service&rsquo;s direction at the drop of a dime can be critical to increasing its chances of success. With the advent of modern software development methodologies &ndash; such as <em>Agile Development</em> &ndash; this ability has become more and more possible for most live-services. Yet, there still exist areas, such as in the database realm, where these methodologies cannot be fully applied. This being the case due to the fact that scaling the database and maintaining a minimal downtime can quickly become a complicated issue. Enter <em>CockroachDB</em>!</p><h3>What is <em>CockroachDB</em>?</h3><p>According to the FAQs page on the <em>CockroachDB</em> website:</p><blockquote><p>&ldquo;<em>CockroachDB</em> is a distributed <em>SQL</em> database built on a transactional and strongly-consistent key-value store. It scales horizontally; survives disk, machine, rack, and even datacenter failures with minimal latency disruption and no manual intervention; supports strongly-consistent <em>ACID</em> transactions; and provides a familiar <em>SQL</em> API for structuring, manipulating, and querying data.&rdquo;</p></blockquote><p>Simply put, <em>CockroachDB</em> combines scalability with the traditional <em>SQL</em> language we have accustomed ourselves to know. This allows programmers to continue to be productive at writing well-structured queries all while automatically making data always-available through redundancy.</p><p>So, if one wanted to create a service that did not require a lot of configuration; required to be reliable, available, and correct; and most importantly, could easily be scaled proportionally to fulfill the service&rsquo;s needs, then <em>CockroachDB</em> would be a great option.</p><p>Although, it should be noted that at the time of this writing there does exist special-cases in which <em>CockroachDB</em> may not be a good fit. One being the case where a service requires &ldquo;very low latency reads and writes.&rdquo; This is due to the lack of <em>CockroachDB&rsquo;s</em> overall performance. Granted, the <em>CockroachDB</em> team has strived to address this issue in their second release, <em>CockroachDB 2.0</em>, and they have acknowledged that they see room for more improvement in future releases.</p><p>If one wishes to allay any concern regarding <em>CockroachDB&rsquo;s</em> performance or if they just want to learn more about how the <em>CockroachDB</em> team has addressed these performance issues, feel free to read their blog: <a href="https://www.cockroachlabs.com/blog/2-dot-0-perf-strides/"><em>CockroachDB 2.0</em> Performance Makes Significant Strides</a>.</p><p>Now, that it is understood how <em>CockroachDB</em> can be useful for one&rsquo;s project, let&rsquo;s dive into the installation phase. This tutorial assumes that <em>Docker</em> and <em>Docker Compose</em> have already been installed in one&rsquo;s system.</p><h3>Getting Started</h3><p>To be able to follow along with this tutorial, the following prerequisite tools will be required.</p><h4>Prerequisites</h4><ul><li><a href="https://docs.docker.com/get-started/">Docker</a></li><li><a href="https://docs.docker.com/compose/gettingstarted/">Docker Compose</a></li></ul><h4>Step 1. Getting Setup</h4><p>We will get started by setting up our working environment:</p><ol><li>Create a new directory and name it <code class="bt-dir">CDBStart</code>.</li><li>Navigate into the newly created directory, <code class="bt-dir">CDBStart</code>.</li><li>Next, in the <code class="bt-dir">CDBStart</code> directory:<ol><li>Create a new file called <code class="bt-file">docker-compose.yml</code>.</li><li>Finally, create a new directory called <code class="bt-dir">Data</code>.</li></ol></li></ol><p>The files and directories you have just created will be used as follows:</p><ul><li>The <code class="bt-dir">CDBStart</code> directory will be the root directory.</li><li>The <code class="bt-file">docker-compose.yml</code> file will be the file to configure <em>Docker Compose</em>.</li><li>The <code class="bt-dir">Data</code> directory will be where <em>CockroachDB</em> will store the data.</li></ul><h4>Step 2. Configuring Docker-Compose</h4><p>We will start off by creating a single-node <em>CockroachDB</em> Service but before we begin, let&rsquo;s create a directory for this single node to store its data.</p><p>So, in the <code class="bt-dir">Data</code> directory that was created earlier, add a new directory and name it <code class="bt-dir">Nest-One</code>. Once the directory <code class="bt-dir">Nest-One</code> has been created, open the <code class="bt-file">docker-compose.yml</code> file in any text-editor or <em>integrated development environment</em> (IDE) and add the following:</p><pre class="bt-code"><code>version: &ldquo;3&rdquo;</code><br /><br /><code>services:</code><br /><code>  cockroach-ui:</code><br /><code>    image: cockroachdb/cockroach</code><br /><code>    container_name: cockroach-ui</code><br /><code>    command: start --insecure</code><br /><code>    volumes:</code><br /><code>      - ./Data/Nest-One:/cockroach/cockroach-data</code><br /><code>    ports:</code><br /><code>      - &ldquo;8080:8080&rdquo;</code></pre><p>Here is a quick-rundown of what we are looking at in this docker-compose configuration file:</p><ul><li><code>version: &ldquo;3&rdquo;</code> tells <em>Docker</em> what formatting version one will be using.</li><li><code>services:</code> tells <em>Docker</em> what services (containers) are being defined.</li><li><code>cockroach-ui:</code> defines one service (container) with the reference name <code>cockroach-ui</code>.</li><li><code>image: cockroachdb/cockroach:</code> tells <em>Docker</em> to use an image named <code>cockroachdb/cockroach</code>. <strong>Note</strong>: if this image does not already exist locally, <em>Docker</em> will download it from <em>Docker</em> Hub or any other defined, remote <em>Docker</em> repository.</li><li><code>container_name: cockroach-ui</code> defines the container&rsquo;s name as <code>cockroach-ui</code>, as opposed to defining it as an auto-generated name. This allows one to address this container using this defined name, later. <strong>Note</strong>: the <code>container_name</code> does not have to be the same as the service&rsquo;s reference name.</li><li><code>command: start --insecure</code> defines the command that the container should run, once it has been initialized. This command basically states that <code>cockroach-ui</code> will be starting <em>CockroachDB</em> in an insecure manner.</li><li><code>volumes:</code> allows one to map host system files or directories with the container&rsquo;s respective files or directories. Here, we are mapping the host&rsquo;s <code class="bt-dir">Nest-One</code> directory onto the container&rsquo;s <code>/cockroach/cockroach-data</code> directory. <strong>Note</strong>: by doing this, all modifications committed to these shared files or directories, on either the host or the container, are reflected both on the host and the container.</li><li><code>ports:</code> defines what ports from the host should map with what ports from the container.</li></ul><p>For more information on what these different configuration keywords mean, <a href="https://docs.docker.com/compose/compose-file/">checkout <em>Docker</em> Compose v3 file&rsquo;s documentation</a>.</p><p>Now, save your work and open up a new terminal window.</p><h4>Step 3. Running CockroachDB</h4><p>In the terminal, navigate to the root directory you just created: <code class="bt-dir">CDBStart</code>. Once in the root-directory, run the following command:</p><pre class="bt-cmd-in"><code>docker-compose up</code></pre><p>If this is the first time using the <code>cockroachdb/cockroach</code> <em>Docker</em> image, <em>Docker</em> will have to first download the image from <em>Docker-Hub</em>. Once the image has been fully downloaded, the service will boot-up and one should see a terminal screen with output-text similar to the following:</p><pre class="bt-cmd-out"><code>Creating network "cdbstart_default" with the default driver</code><br /><code>Pulling cockroach-ui (cockroachdb/cockroach:latest)...</code><br /><code>latest: Pulling from cockroachdb/cockroach</code><br /><code>85b1f47fba49: Pull complete</code><br /><code>c4223f931167: Pull complete</code><br /><code>87e08127dab6: Pull complete</code><br /><code>d164a7a9cf12: Pull complete</code><br /><code>Digest: sha256:91293675e7debef2d180e051d01499f30c4bfefde846e7e9422405d3600e9638</code><br /><code>Status: Downloaded newer image for cockroachdb/cockroach:latest</code><br /><code>Creating cockroach-ui ... done</code><br /><code>Attaching to cockroach-ui</code><br /><code>cockroach-ui    | *</code><br /><code>cockroach-ui    | * WARNING: RUNNING IN INSECURE MODE!</code><br /><code>cockroach-ui    | * </code><br /><code>cockroach-ui    | * - Your cluster is open for any client that can access IP addresses&gt;.</code><br /><code>cockroach-ui    | * - Any user, even root, can log in without providing a password.</code><br /><code>cockroach-ui    | * - Any user, connecting as root, can read or write any data in your cluster.</code><br /><code>cockroach-ui    | * - There is no network encryption nor authentication, and thus no confidentiality.</code><br /><code>cockroach-ui    | * </code><br /><code>cockroach-ui    | * Check out how to secure your cluster: https://www.cockroachlabs.com/docs/v2.0/secure-a-cluster.html</code><br /><code>cockroach-ui    | *</code><br /><code>cockroach-ui    | <em>CockroachDB</em> node starting at 2018-04-12 14:43:04.287553366 +0000 UTC (took 0.9s)</code><br /><code>cockroach-ui    | build:               CCL v2.0.0 @ 2018/04/03 20:56:09 (go1.10)</code><br /><code>cockroach-ui    | admin:               http://4544492f2fc6:8080</code><br /><code>cockroach-ui    | sql:                 postgresql://root@4544492f2fc6:26257?sslmode=disable</code><br /><code>cockroach-ui    | logs:                /cockroach/cockroach-data/logs</code><br /><code>cockroach-ui    | temp dir:            /cockroach/cockroach-data/cockroach-temp430609136</code><br /><code>cockroach-ui    | external I/O path:   /cockroach/cockroach-data/extern</code><br /><code>cockroach-ui    | store[0]:            path=/cockroach/cockroach-data</code><br /><code>cockroach-ui    | status:              initialized new cluster</code><br /><code>cockroach-ui    | clusterID:           ab53236d-262b-46ae-bb24-b457c894dd92</code><br /><code>cockroach-ui    | nodeID:              1</code></pre><p>Now, let\'s verify everything is running accordingly by navigating to <a href="http://localhost:8080">localhost:8080</a> to view <em>CockroachDB&rsquo;s</em> overview dashboard. The dashboard should look like something similar to the following:</p><p><img src="assets/imgs/blog/gswcdbd/dashboard01.png"></p><p>Now, that we have verified that <em>CockroachDB</em> is up and running, let&rsquo;s create a new database, add a table, and add some data to our table.</p><h4>Step 4. Creating A New Database</h4><p>To create a new database to <em>CockroachDB</em>, we will be using <em>CockroachDB&rsquo;s</em> built-in <em>SQL client</em>. To access the <em>SQL client</em>, we are going to have to use a new terminal window to connect to the <em>Docker</em> container we just booted-up.</p><p>So, open-up a new terminal window but do not close the terminal window that is currently running the <em>CockroachDB</em> container named <code>cockroach-ui</code>. Type-in the following command:</p><pre class="bt-cmd-in"><code>docker exec -it cockroach-ui ./cockroach sql --insecure</code></pre><p>This command tells <em>Docker</em> to execute the command <code>./cockroach sql --insecure</code> in the running container named <code>cockroach-ui</code> and the <code>-it</code> flags keep an interactive session open between the container and the host. For more information on <code>docker exec</code>, <a href="https://docs.docker.com/engine/reference/commandline/exec/">see the <em>Docker</em> exec documentation</a>.</p><p>If the command executed successfully, one should have access to the built-in <em>SQL client</em>. It should look like something similar to the following:</p><pre class="bt-cmd-out"><code># Welcome to the cockroach SQL interface.</code><br /><code># All statements must be terminated by a semicolon.</code><br /><code># To exit: CTRL + D.</code><br /><code>#</code><br /><code># Server version: <em>CockroachDB</em> CCL v2.0.0 (x86_64-unknown-linux-gnu, built 2018/04/03 20:56:09, go1.10) (same version as client)</code><br /><code># Cluster ID: ab53236d-262b-46ae-bb24-b457c894dd92</code><br /><code>#</code><br /><code># Enter \\? for a brief introduction.</code><br /><code>#</code><br /><code>warning: no current database set. Use SET database = &lt;dbname&gt; to change, CREATE DATABASE to make a new database.</code></pre><p>To create the new database, through the <em>SQL client</em>, run the following <em>SQL</em> command:</p><pre class="bt-cmd-in"><code>CREATE DATABASE bank;</code></pre><p>A new database named <code>bank</code> should now be created. Next, let&rsquo;s create a new table and add data to the newly created database.</p><h4>Step 5. Adding Data to The New Database</h4><p>Before we can add data to our bank database, we need to create a table in the database. So, in the same terminal window with the <em>SQL client</em> open, type-in the following command:</p><pre class="bt-cmd-in"><code>CREATE TABLE bank.accounts (id INT PRIMARY KEY, balance DECIMAL);</code></pre><p>Now, we can add data to the accounts table in the <code>bank</code> database:</p><pre class="bt-cmd-in"><code>INSERT INTO bank.accounts VALUES (1, 234.56);</code></pre><p>If you want to verify that your database was in fact updated, run the following query in the <em>SQL client</em>:</p><pre class="bt-cmd-in"><code>SELECT * FROM bank.accounts;</code></pre><p>If everything was executed successfully, one should see results similar to the following:</p><pre class="bt-cmd-out"><code>+----+---------+</code><br /><code>| id | balance |</code><br /><code>+----+---------+</code><br /><code>|  1 |  234.56 |</code><br /><code>+----+---------+</code><br /><code>(1 row)</code><br /><br /><code>Time: 2.761443ms</code></pre><p>If you want to verify that your database was updated, through the dashboard, go to <a href="http://localhost:8080">localhost:8080</a> and navigate to the DATABASES page, by selecting the link on the left-hand menu. One should see something similar to the following:</p><p><img src="assets/imgs/blog/gswcdbd/databases01.png"></p><p>That is all you need to get started with the basics of <em>CockroachDB</em>. In the next section, we will add additional nodes to the <em>CockroachDB</em> cluster and we will get to simulate a failure upon a node and witness what happens.</p><p>Before we move on, let&rsquo;s shutdown the currently running <em>CockroachDB</em> node:</p><ul><li>First, exit the <em>SQL client</em> by pressing <code>Ctrl + D</code>.</li><li>Switch over to the terminal window where we ran <code>docker-compose up</code>and press <code>Ctrl + C</code> to exit the session.</li><li>Finally, run the following command in the terminal, to stop the <em>CockroachDB</em> container: <code>docker stop cockroach-ui</code>.</li></ul><p><strong>Note</strong>: by performing these last few steps, one is simply shutting down the <code>cockroach-ui</code> node but not erasing the data that was inserted into the database. To erase the data from the database, one would need to delete the files and directories from the respective directories stored in the <code class="bt-dir">Data</code> directory. For example, the container <code>cockroach-ui</code>&rsquo;s data is stored in <code class="bt-dir">Nest-One</code>. More on this later.</p><h3>Adding Redundancy in <em>CockroachDB</em></h3><p><em>CockroachDB</em> automatically replicates your data behind the scenes but for this to occur, it needs somewhere to replicate this data onto. So, in this section, we will be adding an additional <em>CockroachDB</em> node (container) so that we can create a two-node <em>CockroachDB</em> cluster. Although we will be creating a <em>CockroachDB</em> cluster that only contains two nodes, it should be made clear that we can add many more additional nodes. With that said, let&rsquo;s start configuring our cluster.</p><p>As was explained earlier, <em>CockroachDB</em> does not require a lot of configuration to get things rolling; this includes adding redundancy! All we need to do is boot up an additional <em>CockroachDB</em> node and point it to the first node that we have already created.</p><h4>Step 1. Adding an Additional Node</h4><p>Before we begin, let&rsquo;s create a directory for this second-node to store its data. So, in the <code class="bt-dir">Data</code> directory that was created earlier, add a new directory and name it <code class="bt-dir">Nest-Two</code>.</p><p>Now, sort of like we did in <strong>Step 2</strong> of <strong>Getting Started</strong>, we are going to have to add a second service to the <code class="bt-file">docker-compose.yml</code> file. So, open the <code class="bt-file">docker-compose.yml</code> file in any text-editor or IDE and make the following modifications, marked in bold:</p><pre class="bt-code"><code>version: &ldquo;3&rdquo;</code><br /><br /><code>services:</code><br /><code>  cockroach-ui:</code><br /><code>    image: cockroachdb/cockroach</code><br /><code>    container_name: cockroach-ui</code><br /><code>    command: start --insecure</code><br /><code>    volumes:</code><br /><code>      - ./Data/Nest-One:/cockroach/cockroach-data</code><br /><code>     ports:</code><br /><code>       - &ldquo;8080:8080&rdquo;</code><br /><strong><code>  cockroach-one:</code></strong><br /><strong><code>    image: cockroachdb/cockroach</code></strong><br /><strong><code>    container_name: cockroach-one</code></strong><br /><strong><code>    command: start --insecure --join=cockroach-ui</code></strong><br /><strong><code>    volumes:</code></strong><br /><strong><code>      - ./Data/Nest-Two:/cockroach/cockroach-data</code></strong></pre><p>Here is a quick-rundown of what we have added to this docker-compose configuration file:</p><ul><li><code>cockroach-one:</code> defines an additional service (container) and names it <code>cockroach-one</code>.</li><li><code>image: cockroachdb/cockroach:</code> as previously explained, this tells <em>Docker</em> to use an image named <code>cockroachdb/cockroach</code>.</li><li><code>container_name: cockroach-one</code> defines the container&rsquo;s name as <code>cockroach-one</code>, as opposed to defining an auto-generated name.</li><li><code>command: start &ndash;insecure &ndash;join=cockroach-ui</code> defines the command that <code>cockroach-one</code> should run, once the container has been initialized. This command states that the container should start <em>CockroachDB</em> in an insecure manner and then connect to the <code>cockroach-ui </code>container.</li><li><code>volumes:</code> as previously explained, this allows one to map host system files or directories with the container&rsquo;s respective files or directories. Here, we are mapping the host&rsquo;s <code class="bt-dir">Nest-Two</code> directory into <code>cockroach-one</code>&rsquo;s <code>/cockroach/cockroach-data</code> directory.</li></ul><p>If we were to spin-up this docker-compose configuration file, we would successfully have a <em>CockroachDB</em> cluster that contained two nodes and all is well. Correct? But, what would happen if we wanted to add a separate, independent cluster? For example, say we wanted to add a cluster that strictly contained user-data and we did not want to risk mixing this user-data cluster with the original cluster. How would this be simulated on a single host machine?</p><p>By default, <em>Docker</em> creates a bridge network amongst the defined services in your docker-compose file. This can be confirmed by looking at the terminal-output in <strong>Step 2</strong>, after one runs the docker-compose up command. In the first line of text, we see that <em>Docker</em> created a bridge network named <code>cdbstart_default</code>:</p><pre class="bt-cmd-out"><code>Creating network "cdbstart_default" with the default driver</code></pre><p>One solution would be to simply add more <em>CockroachDB</em> nodes (containers) and have them join one another, without joining the currently established cluster. The newly created nodes would all still be using the same default bridge network, named <code>cdbstart_default</code>, but they would be configured so that they did not join the established cluster.</p><p>Using this solution, if one was not careful, it could lead to the possibility of allowing nodes from one cluster to communicate to another node from a separate cluster. That is something that is highly undesirable. So, how would we get rid of this issue?</p><p>Fortunately, <em>Docker</em> allows us to define and use custom bridge networks. By defining multiple custom bridge networks, we are effectively isolating the clusters into their own networks. Therefore, reducing the possibility of accidentally allowing one node from one cluster to join another cluster.</p><h4>Step 2. Defining A Custom Bridge Network</h4><p>To define a custom bridge network, make the following changes, marked in bold, to your <code class="bt-file">docker-compose.yml</code> file:</p><pre class="bt-code"><code>version: &ldquo;3&rdquo;</code><br /><br /><code>services:</code><br /><code>  cockroach-ui:</code><br /><code>    image: cockroachdb/cockroach</code><br /><code>    container_name: cockroach-ui</code><br /><code>    command: start --insecure</code><br /><code>    volumes:</code><br /><code>      - ./Data/Nest-One:/cockroach/cockroach-data</code><br /><code>    ports:</code><br /><code>      - &ldquo;8080:8080&rdquo;</code><br /><strong><code>    networks:</code></strong><br /><strong><code>      - roachnet</code></strong><br /><code>  cockroach-one:</code><br /><code>    image: cockroachdb/cockroach</code><br /><code>    container_name: cockroach-one</code><br /><code>    command: start --insecure --join=cockroach-ui</code><br /><code>    volumes:</code><br /><code>      - ./Data/Nest-Two:/cockroach/cockroach-data</code><br /><code>    networks:</code><br /><code>      - roachnet</code><br /><br /><strong><code>networks:</code></strong><br /><strong><code>  roachnet:</code></strong></pre><p>Here is a quick-rundown of what we have added to this docker-compose configuration file:</p><ul><li><code>networks: - roachnet</code> in both services (containers) &ndash; <code>cockroach-ui</code> and <code>cockroach-one</code> &ndash; we are instructing the container to use the <code>roachnet</code> network; defined at the bottom of the configuration file.</li><li><code>networks: roachnet:</code> defines a bridge network, named <code>roachnet</code>.</li></ul><p>These changes, to the <code class="bt-file">docker-compose.yml</code> file, have simply defined a bridge network, named <code>roachnet</code>. Then the two nodes (containers) were configured to attach to <code>roachnet</code>. If you would like to learn more about <em>Docker&rsquo;s</em> bridge networks, feel free to <a href="https://docs.docker.com/network/bridge/">read <em>Docker\'s</em> documentation on bridge networks</a>.</p><p>Now, that we have two nodes defined (<code>cockroach-ui</code> and <code>cockroach-one</code>) and they are configured to connect to one another through <code>roachnet</code>. Let&rsquo;s boot up this cluster and see what has changed in the dashboard and the database itself.</p><h4>Step 3. Booting Up Our Two-Node Cluster</h4><p>Just like the steps we took to boot-up our container in <strong>Step 3</strong> of <strong>Getting Started</strong>, we are going to repeat those steps.</p><p>In the terminal, navigate to the root directory: <code class="bt-dir">CDBStart</code>. Once in the root-directory, run the following command:</p><pre class="bt-cmd-in"><code>docker-compose up</code></pre><p>Now, one should see a screen similar to the following:</p><pre class="bt-cmd-out"><code>Creating network "cdbstart_roachnet" with the default driver<br />Recreating cockroach-ui ... done<br />Creating cockroach-one  ... done<br />Attaching to cockroach-one, cockroach-ui<br />cockroach-one    | *<br />cockroach-one    | * WARNING: RUNNING IN INSECURE MODE!<br />cockroach-one    | * <br />cockroach-one    | * - Your cluster is open for any client that can access .<br />cockroach-one    | * - Any user, even root, can log in without providing a password.<br />cockroach-one    | * - Any user, connecting as root, can read or write any data in your cluster.<br />cockroach-one    | * - There is no network encryption nor authentication, and thus no confidentiality.<br />cockroach-one    | * <br />cockroach-one    | * Check out how to secure your cluster: https://www.cockroachlabs.com/docs/v2.0/secure-a-cluster.html<br />cockroach-one    | *<br />cockroach-ui     | *<br />cockroach-ui     | * WARNING: RUNNING IN INSECURE MODE!<br />cockroach-ui     | * <br />cockroach-ui     | * - Your cluster is open for any client that can access .<br />cockroach-ui     | * - Any user, even root, can log in without providing a password.<br />cockroach-ui     | * - Any user, connecting as root, can read or write any data in your cluster.<br />cockroach-ui     | * - There is no network encryption nor authentication, and thus no confidentiality.<br />cockroach-ui     | * <br />cockroach-ui     | * Check out how to secure your cluster: https://www.cockroachlabs.com/docs/v2.0/secure-a-cluster.html<br />cockroach-ui     | *<br />cockroach-ui     | CockroachDB node starting at 2018-04-12 14:56:01.512964431 +0000 UTC (took 0.9s)<br />cockroach-ui     | build:               CCL v2.0.0 @ 2018/04/03 20:56:09 (go1.10)<br />cockroach-ui     | admin:               http://7f596099ee59:8080<br />cockroach-ui     | sql:                 postgresql://root@7f596099ee59:26257?sslmode=disable<br />cockroach-ui     | logs:                /cockroach/cockroach-data/logs<br />cockroach-ui     | temp dir:            /cockroach/cockroach-data/cockroach-temp318177798<br />cockroach-ui     | external I/O path:   /cockroach/cockroach-data/extern<br />cockroach-ui     | store[0]:            path=/cockroach/cockroach-data<br />cockroach-ui     | status:              restarted pre-existing node<br />cockroach-ui     | clusterID:           ab53236d-262b-46ae-bb24-b457c894dd92<br />cockroach-ui     | nodeID:              1<br />cockroach-one    | CockroachDB node starting at 2018-04-12 14:56:02.024231412 +0000 UTC (took 1.4s)<br />cockroach-one    | build:               CCL v2.0.0 @ 2018/04/03 20:56:09 (go1.10)<br />cockroach-one    | admin:               http://f711c614eafb:8080<br />cockroach-one    | sql:                 postgresql://root@f711c614eafb:26257?sslmode=disable<br />cockroach-one    | logs:                /cockroach/cockroach-data/logs<br />cockroach-one    | temp dir:            /cockroach/cockroach-data/cockroach-temp633223067<br />cockroach-one    | external I/O path:   /cockroach/cockroach-data/extern<br />cockroach-one    | store[0]:            path=/cockroach/cockroach-data<br />cockroach-one    | status:              initialized new node, joined pre-existing cluster<br />cockroach-one    | clusterID:           ab53236d-262b-46ae-bb24-b457c894dd92<br />cockroach-one    | nodeID:             </code> 2</pre><p> Notice, on the first line of the terminal&rsquo;s output-text, that we have created a new bridge network, referred to by <em>Docker</em> as <code>cdbstart_roachnet</code>:</p><pre class="bt-cmd-out"><code>Creating network "cdbstart_roachnet" with the default driver</code></pre><p>We also have two nodes up and running: <code>cockroach-ui</code> and <code>cockroach-one</code>. As mentioned earlier, the database, table, and data we created earlier were not erased when we shut down the <code>cockroach-ui</code> container. So, now, we can add more data to that same database.</p><h4>Step 4. Adding Data to The Two-Node Cluster</h4><p>First, we will want to open up a new terminal window so that we can access the built-in <em>SQL client</em>.</p><p>So, open-up a new terminal window but do not close the terminal window that is currently running the <em>CockroachDB</em> containers. Type-in the following command:</p><pre class="bt-cmd-in"><code>docker exec -it cockroach-one ./cockroach sql --insecure</code></pre><p>If the previous command ran successfully, one should expect to see a terminal screen, similar to the following:</p><pre class="bt-cmd-out"><code># Welcome to the cockroach SQL interface.</code><br /><code># All statements must be terminated by a semicolon.</code><br /><code># To exit: CTRL + D.</code><br /><code>#</code><br /><code># Server version: <em>CockroachDB</em> CCL v2.0.0 (x86_64-unknown-linux-gnu, built 2018/04/03 20:56:09, go1.10) (same version as client)</code><br /><code># Cluster ID: ab53236d-262b-46ae-bb24-b457c894dd92</code><br /><code>#</code><br /><code># Enter \\? for a brief introduction.</code><br /><code>#</code><br /><code>warning: no current database set. Use SET database = &lt;dbname&gt; to change, CREATE DATABASE to make a new database.</code></pre><p>Now, we are going to add data through the built-in <em>SQL client</em>, just like we did in <strong>Step 5</strong> of <strong>Getting Started</strong>. First, let&rsquo;s set our current database by running the following command in our <em>SQL client</em>:</p><pre class="bt-cmd-in"><code>SET database = bank;</code></pre><p>Now, let&rsquo;s add more data to the bank table:</p><pre class="bt-cmd-in"><code>INSERT INTO accounts VALUES (2, 77.77);</code></pre><p>Finally, let&rsquo;s verify that all of our data is in fact in the <code>bank</code> table:</p><pre class="bt-cmd-in"><code>SELECT * FROM accounts;</code></pre><p>We should expect to see something similar to the following:</p><pre class="bt-cmd-out"><code>+----+---------+</code><br /><code>| id | balance |</code><br /><code>+----+---------+</code><br /><code>|  1 |  234.56 |</code><br /><code>|  2 |   77.77 |</code><br /><code>+----+---------+</code><br /><code>(2 rows)</code><br /><br /><code>Time: 2.390734ms</code></pre><p>If one has been paying close attention, they will notice that this time they are using <code>cockroach-one</code>&lsquo;s built-in <em>SQL client</em>; as opposed to <code>cockroach-ui</code>&rsquo;s, like was done in <strong>Step 4</strong> of <strong>Getting Started</strong>. Now, even though <code>cockroach-one</code>&rsquo;s <em>SQL client</em> is being used, notice that the database, table, and the data that was inserted through <code>cockroach-ui</code> is still available through <code>cockroach-one</code>.</p><p>At this point, feel free to visit the dashboard and explore what changes have occurred there by navigating to <a href="http://localhost:8080">localhost:8080</a> on any browser. The dashboard should reflect the fact that two nodes are being used in the cluster. Now, let&rsquo;s move forward and put this redundancy to the test by simulating a failure on one of the nodes.</p><h4>Step 5. Verifying Data Redundancy</h4><p>So far, we have demonstrated that the data from each <em>CockroachDB</em> node is available when each are up and running. Now, we are going to simulate a failure on one of the nodes and determine whether the data is in fact replicated onto the other node.</p><p>Before doing so, let&rsquo;s quickly recap what occurred in the previous step, <strong>Step 4</strong>. In the previous step, we inserted data through <code>cockroach-one</code>. Now, we are trying to verify whether that data was replicated onto <code>cockroach-ui</code>. To find out, let&rsquo;s simulate a failure on the <code>cockroach-one</code> node.</p><p>We can simulate a failure on <code>cockroach-one</code> by opening up a third terminal screen and running the following command:</p><pre class="bt-cmd-in"><code>docker kill cockroach-one</code></pre><p>Now, if one were to navigate to <a href="http://localhost:8080">localhost:8080</a> on any browser, they would see a screen similar to the following:</p><p><img src="assets/imgs/blog/gswcdbd/dashboard02.png"></p><p>Notice the summary table on the right-hand side of the screen, one should have the following:</p><ul><li>A total of 2 nodes</li><li>1 healthy &ndash; <code>cockroach-ui</code></li><li>1 suspect &ndash; <code>cockroach-one</code></li></ul><p>Now, let&rsquo;s verify if the data we inserted in the previous step is still available after the failure of <code>cockroach-one</code>.</p><p>We can do so by going back to the terminal screen in which we had a session with the <em>SQL client</em> on <code>cockroach-one</code>. Notice that the session has been terminated because the docker-node is no longer up and running. So, let&rsquo;s connect to the <em>SQL client</em> on <code>cockroach-ui</code>. We can do this by running the following command:</p><pre class="bt-cmd-in"><code>docker exec -it cockroach-ui ./cockroach sql --insecure</code></pre><p>Just like in <strong>Step 4</strong>, let&rsquo;s run the same command to verify whether all of our data is in fact in the <code>bank</code> table:</p><pre class="bt-cmd-in"><code>SELECT * FROM bank.accounts;</code></pre><p>Surely enough, we see that the same data that we saw after we performed the insert in <strong>Step 4</strong>, is still there:</p><pre class="bt-cmd-out"><code>+----+---------+</code><br /><code>| id | balance |</code><br /><code>+----+---------+</code><br /><code>|  1 |  234.56 |</code><br /><code>|  2 |   77.77 |</code><br /><code>+----+---------+</code><br /><code>(2 rows)</code><br /><br /><code>Time: 13.257183ms</code></pre><h3>Conclusion</h3><p>As this orial has demonstrated, getting a <em>CockroachDB</em> cluster up and running does not require much configuration. This makes <em>CockroachDB</em> an ideal database candidate for any service that wishes to have the option to easily scale on all ends.</p><p>Having the ability to easily scale the database and to adapt to its demand allows for a service to be efficient with its resources by maintaining an optimal performance, based upon the demand requirements. Pair this with the fact that the <em>CockroachDB</em> team is continuing to focus on improving the throughput and the latency performance issues of <em>CockroachDB</em>, it may just become the preferred database, in the future.</p><h3>What&rsquo;s Next?</h3><p>It should be pointed out that an important feature that was not covered in this tutorial but would be highly beneficial, in terms of reliability of a <em>CockroachDB</em> cluster, is management automation of the <em>Docker</em> containers. <a href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/"><em>Kubernetes</em> is a platform for managing containerized workloads and services</a>. With <em>Kubernetes</em>, one could configure the <em>CockroachDB</em> cluster to reboot any node upon failure of that given node. Thus, creating and maintaining a more reliable cluster. Stay tuned, as this will be explored in a future blog post and linked here.</p></div>',
        20,
        0
      ),
    ];

    this.blogs = {};

    this.blogsArr.forEach((blog: Blog, idx: number) => {
      this.blogs[blog.hyphenedTitle] = idx;
    });
  }

  getBlogs() {
    return this.blogsArr;
  }

  getBlog(hyphenedTitle) {
    return this.blogsArr[this.blogs[hyphenedTitle]];
  }
}
